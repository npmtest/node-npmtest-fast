{"/home/travis/build/npmtest/node-npmtest-fast/test.js":"/* istanbul instrument in package npmtest_fast */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-fast/lib.npmtest_fast.js":"/* istanbul instrument in package npmtest_fast */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_fast = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_fast = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-fast/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-fast && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_fast */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_fast\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_fast.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_fast.rollup.js'] =\n            local.assetsDict['/assets.npmtest_fast.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_fast.__dirname + '/lib.npmtest_fast.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-fast/node_modules/fast/lib/fast.js":"/*\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n/*\n * Copyright (c) 2016, Joyent, Inc.\n */\n\n/*\n * lib/fast.js: public node-fast interface\n */\n\nvar mod_client = require('./fast_client');\nvar mod_server = require('./fast_server');\n\nexports.FastClient = mod_client.FastClient;\nexports.FastServer = mod_server.FastServer;\n","/home/travis/build/npmtest/node-npmtest-fast/node_modules/fast/lib/fast_client.js":"/*\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n/*\n * Copyright (c) 2016, Joyent, Inc.\n */\n\n/*\n * lib/fast_client.js: public node-fast client interface\n */\n\nvar mod_assertplus = require('assert-plus');\nvar mod_dtrace = require('dtrace-provider');\nvar mod_events = require('events');\nvar mod_microtime = require('microtime');\nvar mod_util = require('util');\nvar VError = require('verror');\n\nvar mod_protocol = require('./fast_protocol');\nvar mod_client_request = require('./fast_client_request');\nvar mod_subr = require('./subr');\n\nexports.FastClient = FastClient;\n\n/*\n * There's one DTrace provider for all clients using this copy of this module.\n */\nvar fastClientProvider = null;\n\n/*\n * We have one counter for the number of clients in the process.  Note that this\n * is a true JavaScript global, so that different copies of this module\n * (presumably at different versions) will still end up with unique client ids.\n */\n/* jsl:declare fastNclients */\nfastNclients = 0;\n\n\n/*\n * A FastClient is an object used to make RPC requests to a remote Fast server.\n * This client does not manage the connection to the remote server.  That's the\n * responsibility of the caller.\n *\n * Named arguments:\n *\n *     log\t\tbunyan-style logger\n *\n *     nRecentRequests\tcount of recent requests to keep track of (for\n *     \t\t\tdebugging)\n *\n *     transport\tusually a socket connected to the remote server, but\n *     \t\t\tthis could be any data-mode duplex stream.  This client\n *     \t\t\twill write messages to the transport and parse responses\n *     \t\t\tfrom the transport.  This client listens for 'error'\n *     \t\t\tevents and end-of-stream only so that it can report\n *     \t\t\trequest failures.  The caller is also expected to listen\n *     \t\t\tfor these errors and handle reconnection appropriately.\n *\n * On 'error', the caller should assume that the current connection to the\n * server is in an undefined state and should not be used any more.  Any\n * in-flight RPC will be terminated gracefully (i.e., with an \"error\" or \"end\"\n * event).\n */\nfunction FastClient(args)\n{\n\tvar self = this;\n\n\tmod_assertplus.object(args, 'args');\n\tmod_assertplus.object(args.log, 'args.log');\n\tmod_assertplus.number(args.nRecentRequests, 'args.nRecentRequests');\n\tmod_assertplus.object(args.transport, 'args.transport');\n\n\tthis.fc_log = args.log;\n\tthis.fc_transport = args.transport;\n\tthis.fc_nrecent = args.nRecentRequests;\n\n\t/* RPC and protocol state */\n\tthis.fc_pending = {}; \t\t/* pending requests */\n\tthis.fc_abandoned = {};\t\t/* abandoned, outstanding requests */\n\tthis.fc_nrpc_started = 0;\t/* requests issued */\n\tthis.fc_nrpc_done = 0;\t\t/* requests completed */\n\tthis.fc_recentrpc = [];\t\t/* recently completed requests */\n\tthis.fc_error = null;\t\t/* first fatal error, if any */\n\tthis.fc_nerrors = 0;\t\t/* count of fatal errors */\n\tthis.fc_rqidalloc = new mod_subr.IdAllocator({\n\t    'min': 1,\n\t    'max': mod_protocol.FP_MSGID_MAX,\n\t    'isAllocated': function isReqIdAllocated(id) {\n\t\treturn (self.fc_pending.hasOwnProperty(id) ||\n\t\t    self.fc_abandoned.hasOwnProperty(id));\n\t    }\n\t});\n\n\t/* transport and message helper objects */\n\tthis.fc_transport_onerr = null;\t/* error listener */\n\tthis.fc_msgencoder = new mod_protocol.FastMessageEncoder();\n\tthis.fc_msgdecoder = new mod_protocol.FastMessageDecoder();\n\n\t/* transport state */\n\tthis.fc_detached = false;\t /* caller detached us */\n\tthis.fc_transport_ended = false; /* transport detached us */\n\n\tif (fastClientProvider === null) {\n\t\tfastClientProvider = fastClientProviderInit();\n\t}\n\n\tmod_assertplus.object(fastClientProvider);\n\tthis.fc_dtid = ++fastNclients;\n\tthis.fc_dtp = fastClientProvider;\n\n\tmod_events.EventEmitter.call(this);\n\tthis.attach();\n}\n\nmod_util.inherits(FastClient, mod_events.EventEmitter);\n\n/*\n * [public] Initiate an RPC request.  Named parameters include:\n *\n *     rpcmethod\t(string)\tname of the RPC method to invoke\n *\n *     rpcargs\t\t(object)\tvalues of arguments passed to the RPC\n *\n *     timeout (optional number)\tmilliseconds after which to abandon the\n *     \t\t\t\t\trequest if no response has been received\n *\n *     log        (optional log)\tbunyan-style logger\n *\n *     ignoreNullValues\t\t\tallow null values to be received from\n *     (optional boolean)\t\tthe server and drop them.  This is used\n *     \t\t\t\t\tfor legacy servers that incorrectly sent\n *     \t\t\t\t\tnull values.  If this is not specified\n *     \t\t\t\t\tand a null value is received, this is\n *     \t\t\t\t\ttreated as a protocol error.\n *\n * The semantics of \"rpcmethod\" and \"rpcargs\" are defined by the server.\n *\n * If \"log\" is not provided, then this request uses a child of the client-level\n * logger.\n *\n * The return value is an object-mode readable stream that emits zero or more\n * messages from the server.  As with other readable streams, \"end\" denotes\n * successful completion, and \"error\" denotes unsuccessful completion.  This\n * stream does not support flow control, so the server must be trusted, and the\n * caller must avoid making requests that return large amounts of data faster\n * than the caller can process it.  Additionally, the stream is already reading\n * when the caller gets it, so there's no need to call read(0) to kick off the\n * RPC.\n *\n * See rpcBufferAndCallback() for an interface that buffers incoming data and\n * invokes a callback upon completion.\n */\nFastClient.prototype.rpc = function (args)\n{\n\tvar msgid, log, request, message;\n\tvar timeoutms = null;\n\tvar self = this;\n\n\tmod_assertplus.object(args, 'args');\n\tmod_assertplus.string(args.rpcmethod, 'method.rpcmethod');\n\tmod_assertplus.array(args.rpcargs, 'args.rpcargs');\n\tmod_assertplus.optionalNumber(args.timeout, 'args.timeout');\n\tmod_assertplus.optionalObject(args.log, 'args.log');\n\tmod_assertplus.optionalBool(args.ignoreNullValues,\n\t    'args.ignoreNullValues');\n\n\tif (typeof (args.timeout) == 'number') {\n\t\tmod_assertplus.ok(args.timeout > 0, 'args.timeout > 0');\n\t\ttimeoutms = args.timeout;\n\t}\n\n\tmsgid = this.allocMessageId();\n\tmod_assertplus.ok(!this.fc_pending.hasOwnProperty(msgid));\n\tlog = args.log ? args.log : this.fc_log;\n\trequest = new mod_client_request.FastClientRequest({\n\t    'client': this,\n\t    'msgid': msgid,\n\t    'rpcmethod': args.rpcmethod,\n\t    'rpcargs': args.rpcargs,\n\t    'ignoreNullValues': args.ignoreNullValues || false,\n\t    'log': log.child({\n\t\t'component': 'FastClientRequest',\n\t\t'msgid': msgid,\n\t\t'rpcmethod': args.rpcmethod\n\t    })\n\t});\n\n\tthis.fc_pending[msgid] = request;\n\tthis.fc_nrpc_started++;\n\n\tif (this.fc_error !== null || this.fc_detached ||\n\t    this.fc_transport_ended) {\n\t\tthis.fc_log.debug('skipping new request (transport detached)');\n\t\trequest.frq_skip = true;\n\t\tthis.requestFail(request, new VError({\n\t\t    'name': 'FastTransportError'\n\t\t}, 'transport detached'));\n\t\treturn (request);\n\t}\n\n\tmessage = {\n\t    'msgid': msgid,\n\t    'status': mod_protocol.FP_STATUS_DATA,\n\t    'data': {\n\t\t'm': {\n\t\t    'uts': mod_microtime.now(),\n\t\t    'name': args.rpcmethod\n\t\t},\n\t\t'd': args.rpcargs\n\t    }\n\t};\n\n\trequest.frq_log.debug({\n\t    'rpcargs': args.rpcargs,\n\t    'timeoutms': timeoutms\n\t}, 'rpc %s: entered', args.rpcmethod);\n\n\tthis.fc_dtp.fire('rpc-start', function () {\n\t    return ([\n\t\tself.fc_dtid,\n\t\trequest.frq_msgid,\n\t\targs.rpcmethod,\n\t\t{\n\t\t    'rpcargs': args.rpcargs,\n\t\t    'timeout': timeoutms\n\t\t}\n\t    ]);\n\t});\n\n\tthis.fc_log.trace(message, 'outgoing message');\n\tthis.fc_msgencoder.write(message);\n\n\tif (timeoutms !== null) {\n\t\trequest.frq_timeout = setTimeout(function onRpcTimeout() {\n\t\t\tself.requestAbandon(request, new VError({\n\t\t\t    'name': 'TimeoutError',\n\t\t\t    'info': {\n\t\t\t\t'timeout': timeoutms\n\t\t\t    }\n\t\t\t}, 'timed out after %d milliseconds', timeoutms));\n\t\t}, timeoutms);\n\t}\n\n\treturn (request);\n};\n\n/*\n * Make an RPC request just like rpc(), but buffer incoming data messages until\n * the request is complete and invoke \"callback\" as callback(err, data, ndata)\n * when the request is complete.  In the callback:\n *\n *     \"err\" is the error, if any\n *\n *     \"data\" is an array of data objects returned with the RPC\n *     (up to \"maxObjectsToBuffer\" objects)\n *\n *     \"ndata\" is a non-negative integer describing how many data objects were\n *     received.  If \"ndata\" is larger than \"data.length\", then messages were\n *     dropped because maxObjectsToBuffer was too small.\n *\n * Note that \"data\" will always be an array and may contain messages even if\n * \"err\" is present.  Similarly, \"ndata\" will always be a non-negative integer.\n *\n * This function takes all of the named arguments that rpc() takes, plus the\n * following required argument:\n *\n *     maxObjectsToBuffer\tthe maximum number of data messages to buffer.\n *     \t\t\t\tThis allows callers to use this interface to\n *     \t\t\t\tmake an RPC call that they expect may only\n *     \t\t\t\tproduce a small number of data messages and know\n *     \t\t\t\tthat a bounded amount of memory will be used,\n *     \t\t\t\teven if the server returns more than the\n *     \t\t\t\texpected number of messages.\n */\nFastClient.prototype.rpcBufferAndCallback = function (args, callback)\n{\n\tvar maxbuffer, request, data, ndata, done;\n\n\tmod_assertplus.object(args, 'args');\n\tmod_assertplus.func(callback, 'callback');\n\tmod_assertplus.number(args.maxObjectsToBuffer,\n\t    'args.maxObjectsToBuffer');\n\tmaxbuffer = args.maxObjectsToBuffer;\n\tmod_assertplus.ok(maxbuffer >= 0);\n\n\tdata = [];\n\tndata = 0;\n\tdone = false;\n\trequest = this.rpc(args);\n\trequest.on('data', function (c) {\n\t\tmod_assertplus.ok(!done);\n\t\tndata++;\n\t\tif (data.length < maxbuffer) {\n\t\t\tdata.push(c);\n\t\t}\n\t});\n\n\trequest.on('error', function (err) {\n\t\tmod_assertplus.ok(!done);\n\t\tdone = true;\n\t\tmod_assertplus.ok(data.length <= ndata);\n\t\tmod_assertplus.ok(data.length <= maxbuffer);\n\t\tcallback(err, data, ndata);\n\t});\n\n\trequest.on('end', function () {\n\t\tmod_assertplus.ok(!done);\n\t\tdone = true;\n\t\tmod_assertplus.ok(data.length <= ndata);\n\t\tmod_assertplus.ok(data.length <= maxbuffer);\n\t\tcallback(null, data, ndata);\n\t});\n\n\treturn (request);\n};\n\n/*\n * Disconnect entirely from the underlying transport.  Do not read from it or\n * write to it and remove any event handlers.\n */\nFastClient.prototype.detach = function ()\n{\n\tif (this.fc_detached) {\n\t\treturn;\n\t}\n\n\tthis.fc_detached = true;\n\tthis.fc_transport.removeListener('error', this.fc_transport_onerr);\n\tthis.fc_transport.unpipe(this.fc_msgdecoder);\n\tthis.fc_msgencoder.unpipe(this.fc_transport);\n\n\tthis.requestAbandonAll(new VError({\n\t    'name': 'FastTransportError'\n\t}, 'client detached from transport'));\n};\n\n/*\n * Public methods for exposing debugging data over kang.\n *\n * Over kang, we expose objects of types:\n *\n *     fastclient\t  describes a single FastClient, including basic\n *\t\t\t  activity stats, any fatal error, and so on.\n *\n *     fastrequest\t  describes a request that's currently outstanding,\n *\t\t\t  including which connection received it, how long it's\n *\t\t\t  been running, and what state it's in\n *\n * We do not provide a kang entry point for stats because we expect that there\n * will be many FastClients in most kang components and they will aggregate up\n * statistics from individual \"fastclient\" objects as desired.\n */\nFastClient.prototype.kangListTypes = function ()\n{\n\treturn ([ 'fastclient', 'fastrequest' ]);\n};\n\nFastClient.prototype.kangListObjects = function (type)\n{\n\tif (type == 'fastclient') {\n\t\treturn ([ this.fc_dtid ]);\n\t}\n\n\tmod_assertplus.equal(type, 'fastrequest');\n\treturn (Object.keys(this.fc_pending).concat(\n\t    Object.keys(this.fc_abandoned)));\n};\n\nFastClient.prototype.kangGetObject = function (type, id)\n{\n\tvar rv, req;\n\n\tif (type == 'fastclient') {\n\t\tmod_assertplus.equal(id, this.fc_dtid);\n\t\trv = {\n\t\t    'id': id,\n\t\t    'nRpcStarted': this.fc_nrpc_started,\n\t\t    'nRpcDone': this.fc_nrpc_done,\n\t\t    'nErrors': this.fc_nerrors,\n\t\t    'error': this.fc_error,\n\t\t    'detached': this.fc_detached,\n\t\t    'transportEnded': this.fc_transport_ended\n\t\t};\n\t\treturn (rv);\n\t}\n\n\tmod_assertplus.equal(type, 'fastrequest');\n\trv = {};\n\trv['clientId'] = this.fc_dtid;\n\trv['msgid'] = id;\n\n\tif (this.fc_pending.hasOwnProperty(id)) {\n\t\treq = this.fc_pending[id];\n\t} else {\n\t\treq = this.fc_abandoned[id];\n\t}\n\n\trv['skipped'] = req.frq_skip;\n\trv['rpcmethod'] = req.frq_rpcmethod;\n\trv['nDataEmitted'] = req.frq_ndata;\n\trv['nMessagesIgnored'] = req.frq_nignored;\n\trv['error'] = req.frq_error;\n\trv['abandoned'] = req.frq_abandoned;\n\trv['doneGraceful'] = req.frq_done_graceful;\n\trv['hasTimeout'] = req.frq_timeout !== null;\n\treturn (rv);\n};\n\n/*\n * private methods\n */\n\nFastClient.prototype.attach = function ()\n{\n\tvar self = this;\n\n\tthis.fc_transport.pipe(this.fc_msgdecoder);\n\tthis.fc_msgencoder.pipe(this.fc_transport, { 'end': false });\n\n\t/*\n\t * It's non-idiomatic to use the \"data\" event because it defeats flow\n\t * control.  However, this abstraction cannot support flow control\n\t * anyway, but clients can already deal with this by limiting the size\n\t * of responses.  Since we know our message decoder is an object-mode\n\t * stream, we may as well just read objects with this handler.\n\t */\n\tthis.fc_msgdecoder.on('data',\n\t    function onDecoderMessage(message) { self.onMessage(message); });\n\tthis.fc_msgdecoder.on('error',\n\t    function onDecoderError(err) { self.fatalError(err); });\n\n\t/*\n\t * By the nature of this abstraction, we don't own the transport.  But\n\t * we still want to know when it either emits \"end\" or \"error\" so that\n\t * we can know that any outstanding requests will not be completed.\n\t * Some modules use \"close\" for this, but transports are not required to\n\t * emit that event.  They should emit one of these two.  We listen for\n\t * \"end\" on the message decoder rather than the transport to deal with\n\t * the fact that there may be queueing of data in between them.\n\t */\n\tthis.fc_msgdecoder.on('end', function onTransportEnd() {\n\t\tvar err;\n\n\t\tself.fc_transport_ended = true;\n\n\t\t/*\n\t\t * There's no problem with seeing end-of-stream as long as we\n\t\t * have no requests pending and are not asked to make any more\n\t\t * requests.  Remember, the caller is separately responsible for\n\t\t * detecting this case for the purpose of reconnection, if\n\t\t * desired.\n\t\t */\n\t\tif (self.fc_nrpc_started > self.fc_nrpc_done) {\n\t\t\terr = new VError({\n\t\t\t    'name': 'FastProtocolError'\n\t\t\t}, 'unexpected end of transport stream');\n\t\t\tself.fatalError(err);\n\t\t}\n\t});\n\n\tthis.fc_transport_onerr = function onTransportError(err) {\n\t\tself.fatalError(new VError({\n\t\t    'name': 'FastTransportError',\n\t\t    'cause': err\n\t\t}, 'unexpected error on transport'));\n\t};\n\n\tthis.fc_transport.on('error', this.fc_transport_onerr);\n};\n\n/*\n * Return the next message id.\n */\nFastClient.prototype.allocMessageId = function ()\n{\n\treturn (this.fc_rqidalloc.alloc());\n};\n\n/*\n * Record an error that's fatal to this client.  We emit the first one and\n * abandon all outstanding requests.  If we see more than one, we simply log and\n * count subsequent ones.\n */\nFastClient.prototype.fatalError = function (err)\n{\n\tthis.fc_log.warn(err);\n\tthis.fc_nerrors++;\n\n\tif (this.fc_error !== null) {\n\t\treturn;\n\t}\n\n\tthis.fc_error = err;\n\tthis.emit('error', err);\n\tthis.requestAbandonAll(err);\n};\n\n/*\n * Abandon all pending requests, as with requestAbandon(request, error).\n */\nFastClient.prototype.requestAbandonAll = function (error)\n{\n\tvar msgid;\n\n\tfor (msgid in this.fc_pending) {\n\t\tmod_assertplus.ok(\n\t\t    this.requestIsPending(this.fc_pending[msgid]));\n\t\tthis.requestAbandon(this.fc_pending[msgid], error);\n\t\tmod_assertplus.ok(!this.fc_pending.hasOwnProperty(msgid));\n\t}\n};\n\n/*\n * Abandon the given request with an error indicating the request was abandoned.\n * If \"error\" is provided, then the given error will be provided as the cause of\n * the abandon error.  If the request has already completed in any way\n * (including having been previously abandoned), this will do nothing.\n */\nFastClient.prototype.requestAbandon = function (request, error)\n{\n\tvar msgid;\n\n\tif (!this.requestIsPending(request)) {\n\t\treturn;\n\t}\n\n\tmod_assertplus.object(error, 'error');\n\n\tmsgid = request.frq_msgid;\n\tmod_assertplus.ok(this.fc_pending[msgid] == request);\n\trequest.frq_abandoned = true;\n\n\t/*\n\t * The history of cancellation in node-fast is somewhat complicated.\n\t * Early versions did not support cancellation of in-flight requests.\n\t * Cancellation was added, but old servers would interpret the\n\t * cancellation message as a new request for the same RPC, which is\n\t * extremely dangerous.  (Usually, the arguments would be invalid, but\n\t * that's only the best-case outcome.)  We could try to avoid this by\n\t * avoiding specifying the RPC method name in the cancellation request.\n\t * Since the protocol was never well-documented, the correctness of this\n\t * approach is mainly determined by what other servers do with it.\n\t * Unfortunately, old servers are likely to handle it as an RPC method\n\t * of some kind, which triggers an unrelated bug: if old servers\n\t * received a request for a method that's not registered, they just\n\t * hang on it, resulting in a resource leak.\n\t *\n\t * Things are a little better on more modern versions of the fast\n\t * server, where if you send a cancellation request and the RPC is not\n\t * yet complete when the server processes it, then the server may stop\n\t * processing the RPC and send back an acknowledgment of sorts.\n\t * However, that doesn't mean the request did not complete, since the\n\t * implementation may not have responded to the cancellation.  And more\n\t * seriously, if the RPC isn't running, the server won't send back\n\t * anything, so we don't know whether we need to expect something or\n\t * not.\n\t *\n\t * To summarize: if we were to send a cancellation request, we would not\n\t * know whether to expect a response, and it's possible that we would\n\t * inadvertently invoke the same RPC again (which could be very\n\t * destructive) or leak resources in the remote server.  For now, we\n\t * punt and declare that request abandonment is purely a client-side\n\t * convenience that directs the client to stop doing anything with\n\t * messages for this request.  We won't actually ask the server to stop\n\t * doing anything.\n\t */\n\tthis.fc_abandoned[request.frq_msgid] = request;\n\tthis.requestFail(request, error);\n};\n\n/*\n * Mark the given request as completed with the specified error.\n */\nFastClient.prototype.requestFail = function (request, error)\n{\n\tmod_assertplus.ok(request.frq_error === null);\n\tmod_assertplus.object(error);\n\n\trequest.frq_error = new VError({\n\t    'name': 'FastRequestError',\n\t    'cause': error,\n\t    'info': {\n\t\t'rpcMsgid': request.frq_msgid,\n\t\t'rpcMethod': request.frq_rpcmethod\n\t    }\n\t}, 'request failed');\n\n\tthis.requestComplete(request);\n\n\t/*\n\t * We may be called in the context of a user action (e.g., if they\n\t * issued a request while the transport was disconnected, or if they're\n\t * abandoning a request).  Defer the 'error' event so they don't have to\n\t * deal with it being emitted synchronously during the execution of that\n\t * action.\n\t */\n\tsetImmediate(function () {\n\t\trequest.emit('error', request.frq_error);\n\t});\n};\n\n/*\n * Mark the given request as completed.\n */\nFastClient.prototype.requestComplete = function (request)\n{\n\tvar msgid;\n\tvar self = this;\n\n\tif (request.frq_timeout !== null) {\n\t\tclearTimeout(request.frq_timeout);\n\t\trequest.frq_timeout = null;\n\t}\n\n\tthis.fc_dtp.fire('rpc-done', function () {\n\t\tvar result, err;\n\n\t\tresult = {};\n\t\tif (request.frq_error !== null) {\n\t\t\terr = VError.cause(request.frq_error);\n\t\t\tresult['error'] = {\n\t\t\t    'name': err ? err.name : '?',\n\t\t\t    'message': err ? err.message : '?'\n\t\t\t};\n\t\t}\n\n\t\treturn ([\n\t\t    self.fc_dtid,\n\t\t    request.frq_msgid,\n\t\t    result\n\t\t]);\n\t});\n\n\tif (request.frq_error !== null) {\n\t\trequest.frq_log.debug(request.frq_error, 'rpc %s: failed',\n\t\t    request.frq_rpcmethod);\n\t} else {\n\t\trequest.frq_log.debug('rpc %s: done', request.frq_rpcmethod);\n\t}\n\n\tmsgid = request.frq_msgid;\n\tmod_assertplus.ok(!this.requestIsPending(request));\n\tmod_assertplus.ok(this.fc_pending[msgid] == request);\n\tdelete (this.fc_pending[msgid]);\n\tthis.fc_nrpc_done++;\n\n\tthis.fc_recentrpc.push(request);\n\tif (this.fc_recentrpc.length > this.fc_nrecent) {\n\t\tthis.fc_recentrpc.shift();\n\t}\n};\n\nFastClient.prototype.onMessage = function (message)\n{\n\tvar request, abandoned, cause;\n\n\tthis.fc_log.trace(message, 'incoming message');\n\n\tmod_assertplus.number(message.msgid,\n\t    'decoder provided message with no msgid');\n\tif (this.fc_pending.hasOwnProperty(message.msgid)) {\n\t\trequest = this.fc_pending[message.msgid];\n\t\tmod_assertplus.ok(!request.frq_abandoned);\n\t\tabandoned = false;\n\t} else if (this.fc_abandoned.hasOwnProperty(message.msgid)) {\n\t\trequest = this.fc_abandoned[message.msgid];\n\t\tmod_assertplus.ok(request.frq_abandoned);\n\t\tabandoned = true;\n\t} else {\n\t\tthis.fatalError(new VError({\n\t\t    'name': 'FastProtocolError',\n\t\t    'info': {\n\t\t\t'fastReason': 'unknown_msgid',\n\t\t\t'fastMsgid': message.msgid\n\t\t    }\n\t\t}, 'fast protocol: received message with unknown msgid %d',\n\t\t    message.msgid));\n\t\treturn;\n\t}\n\n\tmod_assertplus.ok(!request.frq_done_graceful);\n\trequest.frq_last = message;\n\n\t/*\n\t * \"end\" messages are always meaningful because they allow us to clean\n\t * up both normal and abandoned requests.\n\t */\n\tif (message.status == mod_protocol.FP_STATUS_END) {\n\t\tif (abandoned) {\n\t\t\trequest.frq_log.debug('cleaning up abandoned request');\n\t\t\tdelete (this.fc_abandoned[request.frq_msgid]);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Although seldom used, it's technically allowed for\n\t\t\t * END messages to contain data.\n\t\t\t */\n\t\t\tif (this.requestEmitData(request, message)) {\n\t\t\t\trequest.frq_done_graceful = true;\n\t\t\t\tthis.requestComplete(request);\n\t\t\t\trequest.end();\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\n\t/*\n\t * If the request was abandoned, then ignore all other messages.\n\t */\n\tif (abandoned) {\n\t\trequest.frq_log.trace(\n\t\t    'ignoring incoming message (request abandoned)');\n\t\trequest.frq_nignored++;\n\t\treturn;\n\t}\n\n\t/*\n\t * The only reasons we can have an error are because we never sent the\n\t * request out at all (which can never result in us getting here), we\n\t * abandoned the request (which we handled above), or the server already\n\t * sent us an error (in which case we also shouldn't be able to get\n\t * here).\n\t */\n\tmod_assertplus.ok(request.frq_error === null);\n\n\tif (message.status == mod_protocol.FP_STATUS_DATA) {\n\t\trequest.frq_ndata++;\n\t\tthis.requestEmitData(request, message);\n\t\treturn;\n\t}\n\n\tmod_assertplus.equal(message.status, mod_protocol.FP_STATUS_ERROR,\n\t    'decoder emitted message with invalid status');\n\tcause = new VError({\n\t    'name': message.data.d.name,\n\t    'info': message.data.d.info\n\t}, '%s', message.data.d.message);\n\tif (message.data.d.stack) {\n\t\tcause.stack = message.data.d.stack;\n\t}\n\n\t/*\n\t * \"context\" and \"ase_errors\" are reconstituted for historical reasons.\n\t * There's a similar note in lib/fast_server.js.\n\t */\n\tcause.context = message.data.d.context;\n\tcause.ase_errors = message.data.d.ase_errors;\n\n\trequest.frq_done_graceful = true;\n\tthis.requestFail(request, new VError({\n\t    'name': 'FastServerError',\n\t    'cause': cause\n\t}, 'server error'));\n};\n\n/*\n * Emits data contained in \"message\".  Returns true if there was no problem\n * processing this data.  If there was an issue, then the request will be\n * abandoned.\n */\nFastClient.prototype.requestEmitData = function (request, message)\n{\n\tvar i, d;\n\tvar self = this;\n\n\tmod_assertplus.ok(this.requestIsPending(request));\n\n\tfor (i = 0; i < message.data.d.length; i++) {\n\t\td = message.data.d[i];\n\t\tif (d === null) {\n\t\t\tif (request.frq_ignorenull) {\n\t\t\t\trequest.frq_nignored_null++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis.requestAbandon(request, new VError({\n\t\t\t    'name': 'FastProtocolError',\n\t\t\t    'info': {\n\t\t\t\t'rpcMsgid': request.frq_msgid,\n\t\t\t\t'rpcMethod': request.frq_rpcmethod,\n\t\t\t        'rpcMessage': message\n\t\t\t    }\n\t\t\t}, 'server sent \"null\" value'));\n\t\t\treturn (false);\n\t\t} else {\n\t\t\tthis.fc_dtp.fire('rpc-data', function () {\n\t\t\t    return ([\n\t\t\t\tself.fc_dtid,\n\t\t\t\trequest.frq_msgid,\n\t\t\t\td\n\t\t\t    ]);\n\t\t\t});\n\n\t\t\trequest.push(d);\n\t\t}\n\t}\n\n\treturn (true);\n};\n\nFastClient.prototype.requestIsPending = function (request)\n{\n\tmod_assertplus.object(request, 'request');\n\tmod_assertplus.ok(request instanceof\n\t    mod_client_request.FastClientRequest,\n\t    'request is not a FastClientRequest');\n\treturn (!request.frq_done_graceful && request.frq_error === null);\n};\n\n\n/*\n * Initialize the DTrace provider for the Fast client.\n */\nfunction fastClientProviderInit()\n{\n\tvar dtp;\n\n\tdtp = mod_dtrace.createDTraceProvider('fastclient');\n\n\t/*\n\t * The rpc-start probe provides arguments:\n\t *\n\t *     arg0   int\tUnique identifier for this client in this\n\t *     \t\t\tprocess.\n\t *     arg1   int       Message identifier (request identifier).\n\t *     \t\t\tThis is only unique among active requests for a\n\t *     \t\t\tsingle client.  See arg2 for a unique\n\t *     \t\t\tidentifier.\n\t *     arg2   string    RPC method name\n\t *     arg3   string    JSON object with properties for \"rpcargs\" and\n\t *     \t\t\t\"timeout\" (optionally).  Additional properties\n\t *     \t\t\tmay be added here in the future.\n\t */\n\tdtp.addProbe('rpc-start', 'int', 'int', 'char *', 'json');\n\n\t/*\n\t * The rpc-data probe provides arguments:\n\t *\n\t *     arg0   int       Same as for rpc-start.\n\t *     arg1   int       Same as for rpc-start.\n\t *     arg2   string    JSON object describing received data.\n\t */\n\tdtp.addProbe('rpc-data', 'int', 'int', 'json');\n\n\t/*\n\t * The rpc-done probe provides arguments:\n\t *\n\t *     arg0   int       Same as for rpc-start.\n\t *     arg1   int       Same as for rpc-start.\n\t *     arg2   string    JSON object with properties for \"error\".\n\t *     \t\t\tAdditional properties may be added here in the\n\t *     \t\t\tfuture.\n\t */\n\tdtp.addProbe('rpc-done', 'int', 'int', 'json');\n\tdtp.enable();\n\n\treturn (dtp);\n}\n","/home/travis/build/npmtest/node-npmtest-fast/node_modules/fast/lib/bench.js":"/*\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n/*\n * Copyright (c) 2016, Joyent, Inc.\n */\n\n/*\n * lib/bench.js: common facilities for basic benchmarking\n */\n\nvar mod_assertplus = require('assert-plus');\nvar VError = require('verror');\n\nexports.fastBenchWorkloads = fastBenchWorkloads;\n\nvar FastBenchWorkloads = {\n    'sync': {\n\t'name': 'sync',\n\t'description': 'uniform, moderate-sized, synchronous requests',\n\t'cons': FastWorkloadSync\n    },\n\n    'sleep150': {\n\t'name': 'sleep150',\n\t'description': 'uniform, moderate-sized requests with 150ms sleep',\n\t'cons': FastWorkloadSleep150\n    }\n};\n\nfunction fastBenchWorkloads()\n{\n\treturn (FastBenchWorkloads);\n}\n\nfunction FastWorkloadSync() {}\nFastWorkloadSync.prototype.name = function () { return ('sync'); };\nFastWorkloadSync.prototype.nextRequest = function (fastclient, callback)\n{\n\treturn (fastWorkloadRequest({\n\t    'fastClient': fastclient,\n\t    'delay': null\n\t}, callback));\n};\n\nfunction FastWorkloadSleep150() {}\nFastWorkloadSleep150.prototype.name = function () { return ('sleep150'); };\nFastWorkloadSleep150.prototype.nextRequest = function (fastclient, callback)\n{\n\treturn (fastWorkloadRequest({\n\t    'fastClient': fastclient,\n\t    'delay': 150\n\t}, callback));\n};\n\nfunction fastWorkloadRequest(args, callback)\n{\n\tvar fastclient, rpcargs, req, ndata;\n\n\tfastclient = args.fastClient;\n\trpcargs = {\n\t    'rpcmethod': 'fastbench',\n\t    'rpcargs': [ {\n\t\t'echo': [\n\t\t    [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ],\n\t\t    [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ],\n\t\t    [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ],\n\t\t    [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n\t\t]\n\t    } ]\n\t};\n\n\tif (args.delay !== null) {\n\t\trpcargs.rpcargs[0]['delay'] = args.delay;\n\t}\n\n\treq = fastclient.rpc(rpcargs);\n\n\tndata = 0;\n\treq.on('data', function (d) {\n\t\tmod_assertplus.deepEqual(d,\n\t\t    { 'value': [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ] });\n\t\tndata++;\n\t});\n\n\treq.on('end', function (e) {\n\t\tif (ndata != 4) {\n\t\t\tcallback(new Error('unexpected data in response'));\n\t\t} else {\n\t\t\tcallback();\n\t\t}\n\t});\n\n\treq.on('error', function (err) {\n\t\tcallback(new VError(err, 'unexpected server error'));\n\t});\n}\n","/home/travis/build/npmtest/node-npmtest-fast/node_modules/fast/lib/demo_server.js":"/*\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n/*\n * Copyright (c) 2016, Joyent, Inc.\n */\n\n/*\n * lib/demo_server.js: implementations of some RPC functions useful in both the\n * demo server and test suite.\n */\n\nvar mod_fs = require('fs');\nvar mod_lstream = require('lstream');\nvar mod_stream = require('stream');\n\nvar VError = require('verror');\n\nexports.demoRpcs = demoRpcs;\n\nvar demoRpc = [\n    { 'rpcmethod': 'date',\t'rpchandler': fastRpcDate      },\n    { 'rpcmethod': 'echo',\t'rpchandler': fastRpcEcho      },\n    { 'rpcmethod': 'fail',\t'rpchandler': fastRpcFail      },\n    { 'rpcmethod': 'fastbench',\t'rpchandler': fastRpcFastbench },\n    { 'rpcmethod': 'sleep',\t'rpchandler': fastRpcSleep     },\n    { 'rpcmethod': 'words',\t'rpchandler': fastRpcWords     },\n    { 'rpcmethod': 'yes',\t'rpchandler': fastRpcYes       }\n];\n\nfunction demoRpcs()\n{\n\treturn (demoRpc);\n}\n\nfunction fastRpcDate(rpc)\n{\n\tvar when;\n\n\tif (rpc.argv().length !== 0) {\n\t\trpc.fail(new Error('expected no arguments'));\n\t} else {\n\t\twhen = new Date();\n\t\trpc.end({\n\t\t    'timestamp': when.getTime(),\n\t\t    'iso8601': when.toISOString()\n\t\t});\n\t}\n}\n\nfunction fastRpcEcho(rpc)\n{\n\trpc.argv().forEach(function (a) { rpc.write({ 'value': a }); });\n\trpc.end();\n}\n\nfunction fastRpcFail(rpc)\n{\n\tvar errspec, rv;\n\n\tif (rpc.argv().length != 1) {\n\t\trpc.fail(new Error('expected argument'));\n\t\treturn;\n\t}\n\n\terrspec = rpc.argv()[0];\n\tif (typeof (errspec.name) != 'string' ||\n\t    typeof (errspec.message) != 'string' ||\n\t    (errspec.info !== undefined && typeof (errspec.info) != 'object')) {\n\t\trpc.fail(new Error('bad arguments'));\n\t\treturn;\n\t}\n\n\tif (errspec.data && Array.isArray(errspec.data)) {\n\t\terrspec.data.forEach(function (d) {\n\t\t\trpc.write({ 'value': d });\n\t\t});\n\t}\n\n\trv = new VError({\n\t    'name': errspec.name,\n\t    'info': errspec.info || {}\n\t}, '%s', errspec.message);\n\tif (errspec.context)\n\t\trv.context = errspec.context;\n\n\tsetImmediate(function () { rpc.fail(rv); });\n}\n\nfunction fastRpcFastbench(rpc)\n{\n\tvar argv, args;\n\n\targv = rpc.argv();\n\tif (argv.length != 1 || typeof (argv[0]) != 'object' ||\n\t    argv[0] === null) {\n\t\trpc.fail(new Error('expected exactly one object argument'));\n\t\treturn;\n\t}\n\n\targs = argv[0];\n\tif (!args.hasOwnProperty('echo') || !Array.isArray(args['echo'])) {\n\t\trpc.fail(new Error('expected arg.echo'));\n\t\treturn;\n\t}\n\n\tif (typeof (args['delay']) == 'number') {\n\t\tsetTimeout(fastRpcFastbenchFinish, args['delay'], rpc,\n\t\t    args['echo']);\n\t} else {\n\t\tfastRpcFastbenchFinish(rpc, args['echo']);\n\t}\n}\n\nfunction fastRpcFastbenchFinish(rpc, values)\n{\n\tvalues.forEach(function (a) { rpc.write({ 'value': a }); });\n\trpc.end();\n}\n\nfunction fastRpcSleep(rpc)\n{\n\tvar argv, timems, maxtimems;\n\n\targv = rpc.argv();\n\tif (argv.length != 1) {\n\t\trpc.fail(new Error('expected one argument'));\n\t\treturn;\n\t}\n\n\ttimems = argv[0].ms;\n\tmaxtimems = 30 * 60 * 1000;\t/* 30 minutes */\n\tif (typeof (timems) != 'number' || timems < 0 || timems > maxtimems) {\n\t\trpc.fail(new Error('bad value for \"ms\"'));\n\t\treturn;\n\t}\n\n\tsetTimeout(function () { rpc.end(); }, timems);\n}\n\nfunction fastRpcWords(rpc)\n{\n\tvar wordfile, wordstream, lstream, xform;\n\n\tif (rpc.argv().length !== 0) {\n\t\trpc.fail(new Error('expected 0 arguments'));\n\t\treturn;\n\t}\n\n\twordfile = '/usr/dict/words';\n\twordstream = mod_fs.createReadStream(wordfile);\n\tlstream = new mod_lstream();\n\twordstream.pipe(lstream);\n\txform = new mod_stream.Transform({\n\t    'objectMode': true,\n\t    'highWaterMark': 1\n\t});\n\txform._transform = function (c, _, callback) {\n\t\tthis.push({ 'word': c });\n\t\tsetImmediate(callback);\n\t};\n\tlstream.pipe(xform);\n\txform.pipe(rpc);\n\twordstream.on('error', function (err) {\n\t\trpc.fail(new VError(err, 'open/read \"%s\"', wordfile));\n\t});\n}\n\nfunction fastRpcYes(rpc)\n{\n\tvar argv, value, count, i;\n\n\targv = rpc.argv();\n\tif (argv.length != 1) {\n\t\trpc.fail(new Error('expected one argument'));\n\t\treturn;\n\t}\n\n\tvalue = argv[0].value;\n\tcount = argv[0].count;\n\tif (typeof (count) != 'number' || count < 1 || count > 102400) {\n\t\trpc.fail(new VError({\n\t\t    'info': {\n\t\t\t'foundValue': count,\n\t\t\t'minValue': 1,\n\t\t\t'maxValue': 102400\n\t\t    }\n\t\t}, 'count must be an integer in range [1, 102400]'));\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\trpc.write({ 'value': value });\n\t}\n\n\trpc.end();\n}\n","/home/travis/build/npmtest/node-npmtest-fast/node_modules/fast/lib/fast_client_request.js":"/*\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n/*\n * Copyright (c) 2016, Joyent, Inc.\n */\n\n/*\n * lib/fast_client_request.js: represents a single RPC request from a fast\n * client.  This object is the caller's handle on an individual request.\n */\n\nvar mod_assertplus = require('assert-plus');\nvar mod_stream = require('stream');\nvar mod_util = require('util');\nvar VError = require('verror');\n\nvar mod_protocol = require('./fast_protocol');\n\n/* Exported interface */\nexports.FastClientRequest = FastClientRequest;\n\n/*\n * This object is constructed internally by the client interface when beginning\n * an RPC request.  Arguments include:\n *\n *     client\t\ta reference back to the FastClient.  Much of the\n *     \t\t\tfunctionality of this request is implemented in the\n *     \t\t\tclient.\n *\n *     msgid\t\tunique identifier for this request, scoped to this\n *     \t\t\ttransport connection\n *\n *     rpcmethod\tstring name of the remote RPC method to invoke\n *\n *     rpcargs\t\tarray of arguments to pass to the remote RPC method\n *\n *     ignoreNullValues\tsee \"ignoreNullValues\" argument to Fast client's rpc()\n *     \t\t\tmethod.\n *\n *     log\t\tbunyan-style logger\n *\n * A FastClientRequest object is a client-side caller's handle for an\n * outstanding RPC request.  From the caller's perspective, fast requests\n * normally emit zero or more \"data\" messages followed by an \"end\" message.  An\n * \"error\" message at any point along the way indicates that the request will\n * receive no further messages.\n *\n * We model this as an object-mode stream.  'data' events are emitted (along\n * with the data payload) for each incoming Fast 'data' message.  When the\n * request completes gracefully, the stream ends (and emits 'end').  If any\n * error occurs along the way, 'error' is emitted, and no further 'data' or\n * 'end' events will be emitted.  Possible sources of error include:\n *\n *     o server-side error: the server explicitly and cleanly sends us an error\n *\n *     o transport or protocol error: we fail the request locally because of an\n *       error maintaining contact with the server\n *\n *     o local abandonment: the caller abandoned the request\n */\nfunction FastClientRequest(args)\n{\n\tmod_assertplus.object(args, 'args');\n\tmod_assertplus.object(args.client, 'args.client');\n\tmod_assertplus.number(args.msgid, 'args.msgid');\n\tmod_assertplus.string(args.rpcmethod, 'args.rpcmethod');\n\tmod_assertplus.array(args.rpcargs, 'args.rpcargs');\n\tmod_assertplus.object(args.log, 'args.log');\n\tmod_assertplus.bool(args.ignoreNullValues, 'args.ignoreNullValues');\n\n\t/* rpc parameters */\n\tthis.frq_client = args.client;\n\tthis.frq_msgid = args.msgid;\n\tthis.frq_rpcmethod = args.rpcmethod;\n\tthis.frq_rpcargs = args.rpcargs;\n\tthis.frq_ignorenull = args.ignoreNullValues;\n\n\t/*\n\t * RPC state: most RPC requests are immediately transmitted (at least to\n\t * the underlying transport, even if that component ends up queueing\n\t * them).  Once that happens, they complete in one of three ways:\n\t *\n\t *     o gracefully, when the server sends an \"end\" or \"error\" message\n\t *\n\t *     o when the local caller issues an abandonment\n\t *\n\t *     o when there's an error on the transport, after which we do not\n\t *       expect to receive a graceful response\n\t *\n\t * The first two conditions are indicated by frq_done_graceful and\n\t * frq_abandoned.  frq_error is set whenever an error is encountered for\n\t * this request, which may be in any of these conditions.\n\t *\n\t * If the transport is disconnected when the user makes the initial\n\t * request, then we never bother to transmit the request.  We will set\n\t * frq_skip for this case, though only for debugging purposes.\n\t */\n\tthis.frq_done_graceful = false;\t/* recvd \"end\" or \"error\" from server */\n\tthis.frq_abandoned = false;\t/* abandoned locally */\n\tthis.frq_error = null;\t\t/* error, if any */\n\tthis.frq_timeout = null;\t/* timeout handle, if any */\n\n\t/* helpers */\n\tthis.frq_log = args.log;\t/* logger */\n\n\t/* debugging state */\n\tthis.frq_skip = false;\t\t/* RPC was skipped (no transport) */\n\tthis.frq_ndata = 0;\t\t/* data messages emitted */\n\tthis.frq_nignored = 0;\t\t/* count of ignored messages */\n\tthis.frq_nignored_null = 0;\t/* count of ignored \"null\" values */\n\tthis.frq_last = null;\t\t/* last message received */\n\n\t/*\n\t * The high watermark is not really used because we do not support flow\n\t * control.\n\t */\n\tmod_stream.PassThrough.call(this, {\n\t    'objectMode': true,\n\t    'highWaterMark': 16\n\t});\n}\n\nmod_util.inherits(FastClientRequest, mod_stream.PassThrough);\n\nFastClientRequest.prototype.abandon = function ()\n{\n\t/*\n\t * This method is just a convenience alias for the guts that happen in\n\t * the client's requestAbandon() method, where all the real work\n\t * happens.\n\t */\n\treturn (this.frq_client.requestAbandon(this, new VError({\n\t    'name': 'FastRequestAbandonedError'\n\t}, 'request abandoned by user')));\n};\n\nFastClientRequest.prototype.requestId = function ()\n{\n\treturn (this.frq_msgid);\n};\n","/home/travis/build/npmtest/node-npmtest-fast/node_modules/fast/lib/fast_protocol.js":"/*\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n/*\n * Copyright (c) 2016, Joyent, Inc.\n */\n\n/*\n * lib/fast_protocol.js: fast protocol definitions\n */\n\nvar mod_assertplus = require('assert-plus');\nvar mod_crc = require('crc');\nvar mod_stream = require('stream');\nvar mod_util = require('util');\nvar VError = require('verror');\n\n/* Exported interface */\nexports.fastMessageEncode = fastMessageEncode;\nexports.FastMessageEncoder = FastMessageEncoder;\nexports.FastMessageDecoder = FastMessageDecoder;\n/* Protocol constants are exported below. */\n\n/*\n * Protocol definition\n *\n * All fast protocol messages look like the following:\n *\n *    0x00   +---------+--------+---------+---------+\n *           | VERSION | TYPE   | STATUS  | MSGID1  |\n *    0x04   +---------+--------+---------+---------+\n *           | MSGID2  | MSGID3 | MSGID4  | CRC1    |\n *    0x08   +---------+--------+---------+---------+\n *           | CRC2    | CRC3   | CRC4    | DLEN1   |\n *    0x0c   +---------+--------+---------+---------+\n *           | DLEN2   | DLEN3  | DLEN4   | DATA0   |\n *    0x10   +---------+--------+---------+---------+\n *           | DATAN...                             |\n *           +---------+--------+---------+---------+\n *\n * VERSION   1-byte integer.  The only supported value is \"1\".\n *\n * TYPE      1-byte integer.  The only supported value is TYPE_JSON (0x1),\n *           indicating that the data payload is an encoded JSON object.\n *\n * STATUS    1-byte integer.  The only supported values are:\n *\n *     STATUS_DATA  0x1  indicates a \"data\" message\n *\n *     STATUS_END   0x2  indicates an \"end\" message\n *\n *     STATUS_ERROR 0x3  indicates an \"error\" message\n *\n * MSGID1...MSGID4    4-byte big-endian unsigned integer, a unique identifier\n *                    for this message\n *\n * CRC1...CRC4        4-byte big-endian unsigned integer representing the CRC16\n *                    value of the data payload\n *\n * DLEN0...DLEN4      4-byte big-endian unsigned integer representing the number\n *                    of bytes of data payload that follow\n *\n * DATA0...DATAN      Data payload.  This is a JSON-encoded object (for TYPE =\n *                    TYPE_JSON).  The encoding length in bytes is given by the\n *                    DLEN0...DLEN4 bytes.\n *\n * Due to historical bugs in node-crc, the CRC implementation used in version 1\n * of the protocol is essentially incompatible with any CRC implementation other\n * than the one provided by node-crc version 0.x.\n */\n\n/*\n * Message IDs: each Fast message has a message id, which is scoped to the Fast\n * connection.  We allocate these sequentially from a circular 31-bit space.\n */\nvar FP_MSGID_MAX        = Math.pow(2, 31) - 1;\nexports.FP_MSGID_MAX    = FP_MSGID_MAX;\n\n/*\n * Field offsets\n */\nvar FP_OFF_VERSION      = 0x0;\nvar FP_OFF_TYPE         = FP_OFF_VERSION + 0x1;\t/* 0x1 */\nvar FP_OFF_STATUS       = FP_OFF_TYPE + 0x1;\t/* 0x2 */\nvar FP_OFF_MSGID        = FP_OFF_STATUS + 0x1;   /* 0x3 */\nvar FP_OFF_CRC          = FP_OFF_MSGID + 0x4;\t/* 0x7 */\nvar FP_OFF_DATALEN      = FP_OFF_CRC + 0x4;\t/* 0xb */\nvar FP_OFF_DATA         = FP_OFF_DATALEN + 0x4;\t/* 0xf */\nexports.FP_OFF_VERSION  = FP_OFF_VERSION;\nexports.FP_OFF_TYPE     = FP_OFF_TYPE;\nexports.FP_OFF_STATUS   = FP_OFF_STATUS;\nexports.FP_OFF_MSGID    = FP_OFF_MSGID;\nexports.FP_OFF_CRC      = FP_OFF_CRC;\nexports.FP_OFF_DATALEN  = FP_OFF_DATALEN;\nexports.FP_OFF_DATA     = FP_OFF_DATA;\n\n\n/* size (in bytes) of each message header */\nvar FP_HEADER_SZ        = FP_OFF_DATA;\t\t/* 0xf */\nexports.FP_HEADER_SZ    = FP_HEADER_SZ;\n\n/* possible values for the \"status\" byte */\nvar FP_STATUS_DATA      = 0x1;\nvar FP_STATUS_END       = 0x2;\nvar FP_STATUS_ERROR     = 0x3;\nexports.FP_STATUS_DATA  = FP_STATUS_DATA;\nexports.FP_STATUS_END   = FP_STATUS_END;\nexports.FP_STATUS_ERROR = FP_STATUS_ERROR;\n\n/* possible values for the \"type\" byte */\nvar FP_TYPE_JSON        = 0x1;\nexports.FP_TYPE_JSON    = FP_TYPE_JSON;\n\n/* possible values for the \"version\" byte */\nvar FP_VERSION_1           = 0x1;\nvar FP_VERSION_CURRENT     = FP_VERSION_1;\nexports.FP_VERSION_1       = FP_VERSION_1;\nexports.FP_VERSION_CURRENT = FP_VERSION_CURRENT;\n\n\n/*\n * Encode a logical message for sending over the wire.  This requires the\n * following named properties:\n *\n *     msgid    (number) message identifier -- see lib/fast.js\n *\n *     data     (object) represents message contents.  At this level, this\n *\t\t\t can be any plain-old JavaScript object.\n *\n *     status   (number) message \"status\" (one of FP_STATUS_DATA, FP_STATUS_END,\n *\t\t\t or FP_STATUS_ERROR).\n *\n * Failure to match these requirements is a programmer error that may result in\n * a synchronously thrown exception that should not be caught.\n */\nfunction fastMessageEncode(msg)\n{\n\tvar buffer, data_encoded, datalen, crc16;\n\n\tmod_assertplus.object(msg, 'msg');\n\tmod_assertplus.ok(typeof (msg.msgid) == 'number' &&\n\t    Math.floor(msg.msgid) == msg.msgid &&\n\t    msg.msgid >= 0 && msg.msgid <= FP_MSGID_MAX,\n\t    'msg.msgid is not an integer between 0 and FP_MSGID_MAX');\n\tmod_assertplus.object(msg.data, 'msg.data');\n\tmod_assertplus.number(msg.status, 'msg.status');\n\n\tswitch (msg.status) {\n\tcase FP_STATUS_DATA:\n\tcase FP_STATUS_END:\n\tcase FP_STATUS_ERROR:\n\t\tbreak;\n\tdefault:\n\t\tthrow (new VError('unsupported fast message status'));\n\t}\n\n\tdata_encoded = JSON.stringify(msg.data);\n\tcrc16 = mod_crc.crc16(data_encoded);\n\tdatalen = Buffer.byteLength(data_encoded);\n\tbuffer = new Buffer(FP_HEADER_SZ + datalen);\n\tbuffer.writeUInt8(FP_VERSION_CURRENT, FP_OFF_VERSION);\n\tbuffer.writeUInt8(FP_TYPE_JSON, FP_OFF_TYPE);\n\tbuffer.writeUInt8(msg.status, FP_OFF_STATUS);\n\tbuffer.writeUInt32BE(msg.msgid, FP_OFF_MSGID);\n\tbuffer.writeUInt32BE(crc16, FP_OFF_CRC);\n\tbuffer.writeUInt32BE(datalen, FP_OFF_DATALEN);\n\tbuffer.write(data_encoded, FP_OFF_DATA, datalen, 'utf8');\n\treturn (buffer);\n}\n\n/*\n * Decode a fast message from a buffer that's known to contain a single,\n * well-formed message.  All of the protocol fields are known to be valid (e.g.,\n * version, type, status, and msgid) at this point, but the data has not been\n * read, so the CRC has not been validated.\n */\nfunction fastMessageDecode(header, buffer)\n{\n\tvar datalen, datastr, json, calc;\n\n\tmod_assertplus.number(header.datalen, 'header.datalen');\n\tdatalen = header.datalen;\n\tmod_assertplus.equal(buffer.length, FP_OFF_DATA + datalen);\n\tdatastr = buffer.toString('utf8', FP_OFF_DATA);\n\tcalc = mod_crc.crc16(datastr);\n\n\tif (calc != header.crc) {\n\t\treturn (new VError({\n\t\t    'name': 'FastProtocolError',\n\t\t    'info': {\n\t\t\t'fastReason': 'bad_crc',\n\t\t\t'crcCalculated': calc,\n\t\t\t'crcExpected': header.crc\n\t\t    }\n\t\t}, 'fast protocol: expected CRC %s, found %s',\n\t\t    header.crc, calc));\n\t}\n\n\ttry {\n\t\tjson = JSON.parse(datastr);\n\t} catch (ex) {\n\t\treturn (new VError({\n\t\t    'name': 'FastProtocolError',\n\t\t    'cause': ex,\n\t\t    'info': {\n\t\t\t'fastReason': 'invalid_json'\n\t\t    }\n\t\t}, 'fast protocol: invalid JSON in \"data\"'));\n\t}\n\n\tif (typeof (json) != 'object' || json === null) {\n\t\treturn (new VError({\n\t\t    'name': 'FastProtocolError',\n\t\t    'info': {\n\t\t\t'fastReason': 'bad_data'\n\t\t    }\n\t\t}, 'fast protocol: message data must be a non-null object'));\n\t}\n\n\tif ((header.status == FP_STATUS_DATA ||\n\t    header.status == FP_STATUS_END) && !Array.isArray(json.d)) {\n\t\treturn (new VError({\n\t\t    'name': 'FastProtocolError',\n\t\t    'info': {\n\t\t\t'fastReason': 'bad_data_d'\n\t\t    }\n\t\t}, 'fast protocol: data.d for DATA and END messages must be ' +\n\t\t    'an array'));\n\t}\n\n\tif (header.status == FP_STATUS_ERROR &&\n\t    (typeof (json.d) != 'object' || json.d === null ||\n\t    typeof (json.d.name) != 'string' ||\n\t    typeof (json.d.message) != 'string')) {\n\t\treturn (new VError({\n\t\t    'name': 'FastProtocolError',\n\t\t    'info': {\n\t\t\t'fastReason': 'bad_error'\n\t\t    }\n\t\t}, 'fast protocol: data.d for ERROR messages must have name ' +\n\t\t    'and message'));\n\t}\n\n\treturn ({\n\t    'status': header.status,\n\t    'msgid': header.msgid,\n\t    'data': json\n\t});\n}\n\n/*\n * Transform stream that takes logical messages and emits a buffer representing\n * that message (for sending over the wire).\n */\nfunction FastMessageEncoder()\n{\n\tmod_stream.Transform.call(this, {\n\t    'highWaterMark': 16,\n\t    'objectMode': true\n\t});\n}\n\nmod_util.inherits(FastMessageEncoder, mod_stream.Transform);\n\nFastMessageEncoder.prototype._transform = function (chunk, _, callback)\n{\n\tthis.push(fastMessageEncode(chunk));\n\tsetImmediate(callback);\n};\n\n\n/*\n * Transform stream that takes bytes (via Buffer objects) and emits an object\n * representing the encoded Fast message.\n */\nfunction FastMessageDecoder()\n{\n\tmod_stream.Transform.call(this, {\n\t    'objectMode': true\n\t});\n\n\t/* current state */\n\tthis.md_buffer = null;\t\t/* unparsed data */\n\tthis.md_havebytes = 0;\t\t/* bytes of unparsed data */\n\tthis.md_done = false;\t\t/* we've read end-of-stream */\n\tthis.md_error = null;\t\t/* fatal error */\n\tthis.md_pushing = false;\t/* currently calling push() */\n\n\t/* current header */\n\tthis.md_version = null;\n\tthis.md_type = null;\n\tthis.md_status = null;\n\tthis.md_msgid = null;\n\tthis.md_crc = null;\n\tthis.md_datalen = null;\n\n\t/* debug information */\n\tthis.md_nmessages = 0;\n\tthis.md_nbytes = 0;\n}\n\nmod_util.inherits(FastMessageDecoder, mod_stream.Transform);\n\nFastMessageDecoder.prototype._transform = function (chunk, _, callback)\n{\n\tthis.md_havebytes += chunk.length;\n\n\tif (this.md_buffer === null) {\n\t\tmod_assertplus.equal(this.md_havebytes, chunk.length);\n\t\tthis.md_buffer = chunk;\n\t} else {\n\t\tthis.md_buffer = Buffer.concat(\n\t\t    [ this.md_buffer, chunk ], this.md_havebytes);\n\t}\n\n\tthis.md_nbytes += chunk.length;\n\tthis.decode(callback);\n};\n\nFastMessageDecoder.prototype._flush = function (callback)\n{\n\tthis.md_done = true;\n\tthis.decode(callback);\n};\n\nFastMessageDecoder.prototype.decode = function (callback)\n{\n\tvar buf, msg;\n\n\tif (this.md_pushing) {\n\t\treturn;\n\t}\n\n\tmod_assertplus.ok(this.md_error === null);\n\n\twhile (this.md_havebytes >= FP_HEADER_SZ) {\n\t\tbuf = this.md_buffer;\n\t\tmod_assertplus.equal(buf.length, this.md_havebytes);\n\t\tmod_assertplus.ok(buf !== null);\n\t\tmod_assertplus.ok(this.md_error === null);\n\t\tmod_assertplus.ok(this.md_version === null);\n\n\t\tthis.md_version = buf.readUInt8(FP_OFF_VERSION);\n\t\tif (this.md_version != FP_VERSION_CURRENT) {\n\t\t\tthis.md_error = new VError({\n\t\t\t    'name': 'FastProtocolError',\n\t\t\t    'info': {\n\t\t\t\t'fastReason': 'unsupported_version',\n\t\t\t\t'foundVersion': this.md_version\n\t\t\t    }\n\t\t\t}, 'fast protocol: unsupported version %d',\n\t\t\t    this.md_version);\n\t\t\tbreak;\n\t\t}\n\n\t\tthis.md_type = buf.readUInt8(FP_OFF_TYPE);\n\t\tif (this.md_type != FP_TYPE_JSON) {\n\t\t\tthis.md_error = new VError({\n\t\t\t    'name': 'FastProtocolError',\n\t\t\t    'info': {\n\t\t\t        'fastReason': 'unsupported_type',\n\t\t\t\t'foundType': this.md_type\n\t\t\t    }\n\t\t\t}, 'fast protocol: unsupported type 0x%x',\n\t\t\t    this.md_type);\n\t\t\tbreak;\n\t\t}\n\n\t\tthis.md_status = buf.readUInt8(FP_OFF_STATUS);\n\t\tswitch (this.md_status) {\n\t\tcase FP_STATUS_DATA:\n\t\tcase FP_STATUS_END:\n\t\tcase FP_STATUS_ERROR:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthis.md_error = new VError({\n\t\t\t    'name': 'FastProtocolError',\n\t\t\t    'info': {\n\t\t\t        'fastReason': 'unsupported_status',\n\t\t\t\t'foundStatus': this.md_status\n\t\t\t    }\n\t\t\t}, 'fast protocol: unsupported status 0x%x',\n\t\t\t    this.md_status);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (this.md_error !== null) {\n\t\t\tbreak;\n\t\t}\n\n\t\tthis.md_msgid = buf.readUInt32BE(FP_OFF_MSGID);\n\t\tif (this.md_msgid < 0 || this.md_msgid > FP_MSGID_MAX) {\n\t\t\tthis.md_error = new VError({\n\t\t\t    'name': 'FastProtocolError',\n\t\t\t    'info': {\n\t\t\t\t'fastReason': 'invalid_msgid',\n\t\t\t\t'foundMsgid': this.md_msgid\n\t\t\t    }\n\t\t\t}, 'fast protocol: invalid msgid %s', this.md_msgid);\n\t\t\tbreak;\n\t\t}\n\n\t\tthis.md_crc = buf.readUInt32BE(FP_OFF_CRC);\n\t\tthis.md_datalen = buf.readUInt32BE(FP_OFF_DATALEN);\n\n\t\tif (this.md_havebytes < FP_HEADER_SZ + this.md_datalen) {\n\t\t\t/*\n\t\t\t * We don't have enough bytes to continue.  Stop now.\n\t\t\t * We'll end up re-parsing the header again when we have\n\t\t\t * more data.  If that turns out to be expensive, we can\n\t\t\t * rework this code to keep track of where we were.\n\t\t\t */\n\t\t\tthis.md_version = null;\n\t\t\tthis.md_type = null;\n\t\t\tthis.md_status = null;\n\t\t\tthis.md_msgid = null;\n\t\t\tthis.md_crc = null;\n\t\t\tthis.md_datalen = null;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We have a complete message.  Consume it and update our buffer\n\t\t * state.\n\t\t */\n\t\tbuf = this.md_buffer.slice(0, FP_HEADER_SZ + this.md_datalen);\n\t\tthis.md_buffer = this.md_buffer.slice(\n\t\t    FP_HEADER_SZ + this.md_datalen);\n\t\tthis.md_havebytes -= buf.length;\n\t\tmsg = fastMessageDecode({\n\t\t    'version': this.md_version,\n\t\t    'type': this.md_type,\n\t\t    'status': this.md_status,\n\t\t    'msgid': this.md_msgid,\n\t\t    'crc': this.md_crc,\n\t\t    'datalen': this.md_datalen\n\t\t}, buf);\n\t\tif (msg instanceof Error) {\n\t\t\tthis.md_error = msg;\n\t\t\tbreak;\n\t\t}\n\n\t\tthis.md_version = null;\n\t\tthis.md_type = null;\n\t\tthis.md_status = null;\n\t\tthis.md_msgid = null;\n\t\tthis.md_crc = null;\n\t\tthis.md_datalen = null;\n\n\t\tthis.md_pushing = true;\n\t\tthis.push(msg);\n\t\tthis.md_pushing = false;\n\t\tthis.md_nmessages++;\n\t}\n\n\tif (this.md_error === null && this.md_havebytes > 0 && this.md_done) {\n\t\tthis.md_error = new VError({\n\t\t    'name': 'FastProtocolError',\n\t\t    'info': {\n\t\t\t'fastReason': 'incomplete_message'\n\t\t    }\n\t\t}, 'fast protocol: incomplete message at end-of-stream');\n\t}\n\n\tif (this.md_error !== null) {\n\t\tsetImmediate(callback, this.md_error);\n\t} else {\n\t\tsetImmediate(callback);\n\t}\n};\n","/home/travis/build/npmtest/node-npmtest-fast/node_modules/fast/lib/fast_server.js":"/*\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n/*\n * Copyright (c) 2017, Joyent, Inc.\n */\n\n/*\n * lib/fast_server.js: public node-fast server interface\n *\n * The public interface for this module is the FastServer class, which takes a\n * server socket and manages connections to clients that connect to the server.\n * Callers register RPC method handlers with the server, and their handler\n * functions are invoked when RPC requests are received for the registered\n * method.  RPC handlers are functions that take a single argument, an RPC\n * context, through which the handler can access the RPC arguments and send data\n * back to the client.\n *\n *\n * Flow control\n *\n * The implementation of the server is structured primarily into object-mode\n * streams to support Node's built-in flow control.  This is only of limited\n * utility at this time, since the client does not support per-request flow\n * control.  However, if a client is itself reading slowly, then this mechanism\n * allows the server manage backpressure appropriately.\n *\n * The RPC context argument provided to RPC method handlers is itself an\n * object-mode stream.  Objects written to the stream are sent to the client.\n * When the stream is ended, an \"end\" message is written to the client, which\n * signifies the successful completion of the RPC call.  The stream pipeline\n * from the RPC context to the client socket fully supports flow control, so the\n * stream will used a bounded amount of memory as long as the RPC method\n * respects Node's flow-control semantics (e.g., stops writing to the stream\n * when write() returns false).  The pipeline looks like this:\n *\n *     RPC request context    (provided as argument to RPC method handlers)\n *         |\n *         | (pipe: objects)\n *         v\n *     FastRpcResponseEncoder (wraps objects in Fast \"DATA\" messages, and\n *         |                  terminates the stream with an \"END\" message)\n *         | (pipe: objects)\n *         v\n *     FastMessageEncoder     (serializes logical Fast messages into buffers)\n *         |\n *         | (pipe: bytes)\n *         v\n *     Client socket          (usually a net.Socket object for TCP)\n *\n * Of course, many of these pipelines may be piped to the same net.Socket\n * object.  This has an unexpected, unfortunate scaling limitation: the\n * completion of a pipe() operation causes Node to remove event listeners, and\n * EventEmitter.removeListener() is O(N), where N is the number of listeners for\n * the same event.  As a result, if a client maintains N concurrent requests,\n * then completion of each request will run into this O(N) step.  This results\n * in an O(N^2) factor in the overall time to complete N requests.  The Node API\n * does not seem fixable.  We could implement a tree of EventEmitters that\n * funnel into the socket, but it's not clear at this point that this\n * consideration is worthwhile.  In practice, Fast servers are more likely to\n * see many clients making a small number of requests each rather than a small\n * number of clients making a large number of requests each, and this deployment\n * model is recommended to avoid this scaling limiter.\n *\n * Flow control is less well-supported on the receiving side because it's less\n * clear what the source of backpressure should be.  The pipeline looks like\n * this:\n *\n *    +---------------------------------------------------------------------+\n *    | Per-connection pipeline                                             |\n *    | -----------------------                                             |\n *    |                                                                     |\n *    |    Client socket             (usually a net.Socket object for TCP)  |\n *    |        |                                                            |\n *    |        | (pipe: bytes)                                              |\n *    |        v                                                            |\n *    |    FastMessageDecoder        (unmarshals Fast messages from bytes   |\n *    |        |                     received on the socket)                |\n *    |        | (pipe: objects)                                            |\n *    |        v                                                            |\n *    |    FastRpcConnectionDecoder  (tags incoming Fast messages with a    |\n *    |        |                     connection identifier for session      |\n *    |        | (pipe: objects)     tracking)                              |\n *    |        |                                                            |\n *    +------- | -----------------------------------------------------------+\n *             |\n *             v\n *       FastMessageHandler          (one for the entire server that invokes\n *                                   server.onMessage() for each message)\n *\n * Since there are many connections and one FastMessageHandler for the server,\n * the whole picture looks like this:\n *\n *                    Connection  Connection  Connection\n *                     pipeline    pipeline    pipeline\n *                         |           |           |\n *                   ...   |   ...     |   ...     | ...\n *                         |           |           |\n *                         v           v           v\n *                       +---------------------------+\n *                       |    FastMessageHandler     |\n *                       +---------------------------+\n *                                     |\n *                                     v\n *                             server.onMessage()\n *\n * The FastMessageHandler currently provides no backpressure.  If desired, a\n * a simple throttle could flow-control the entire pipeline based on concurrent\n * outstanding RPC requests.  A more complex governor could look at the the\n * count of requests per connection and prioritize some notion of fairness among\n * them.  As a result of the lack of flow control here, it's possible for any\n * client to overwhelm the server by blasting messages to it; however, because\n * the intended deployment is not a byzantine environment, this issue is not\n * considered a priority for future work.\n */\n\nvar mod_assertplus = require('assert-plus');\nvar mod_dtrace = require('dtrace-provider');\nvar mod_events = require('events');\nvar mod_jsprim = require('jsprim');\nvar mod_microtime = require('microtime');\nvar mod_stream = require('stream');\nvar mod_util = require('util');\nvar VError = require('verror');\n\nvar mod_protocol = require('./fast_protocol');\nvar mod_subr = require('./subr');\n\nexports.FastServer = FastServer;\n\n/*\n * This maximum is chosen pretty arbitrarily.\n */\nvar FS_MAX_CONNID = (1 << 30);\n\n/*\n * There's one DTrace provider for all servers using this copy of this module.\n */\nvar fastServerProvider = null;\n\n/*\n * We have one counter for the number of servers in this process.  This is a\n * true JavaScript global.  See the note in lib/fast_client.js.\n */\n/* jsl:declare fastNservers */\nfastNservers = 0;\n\n/*\n * Instantiate a new server for handling RPC requests made from remote Fast\n * clients.  This server does not manage the underlying server socket.  That's\n * the responsibility of the caller.\n *\n * Named arguments:\n *\n *     log\t\tbunyan-style logger\n *\n *     server\t\tserver object that emits 'connection' events\n *\n * Use the server by invoking the registerRpcMethod() method to register\n * handlers for named RPC methods.\n */\nfunction FastServer(args)\n{\n\tvar self = this;\n\n\tmod_assertplus.object(args, 'args');\n\tmod_assertplus.object(args.log, 'args.log');\n\tmod_assertplus.object(args.server, 'args.server');\n\n\tthis.fs_log = args.log;\t\t/* logger */\n\tthis.fs_server = args.server;\t/* server socket */\n\tthis.fs_handlers = {};\t\t/* registered handlers, by name */\n\tthis.fs_conns = {};\t\t/* active connections */\n\tthis.fs_msghandler = new FastMessageHandler({\n\t    'server': this\n\t});\n\t/*\n\t * See the comments below on use of setMaxListeners().\n\t */\n\tthis.fs_msghandler.setMaxListeners(0);\n\tthis.fs_connallocator = new mod_subr.IdAllocator({\n\t    'min': 1,\n\t    'max': FS_MAX_CONNID,\n\t    'isAllocated': function isConnIdAllocated(id) {\n\t\treturn (self.fs_conns.hasOwnProperty(id));\n\t    }\n\t});\n\tthis.fs_closed = false;\t\t/* server is shutting down */\n\n\tthis.fs_server.on('connection',\n\t    function onConnection(sock) { self.connCreate(sock); });\n\n\tthis.fs_nignored_noconn = 0;\t/* count of msgs ignored: no conn */\n\tthis.fs_nignored_badconn = 0;\t/* count of msgs ignored: bad conn */\n\tthis.fs_nignored_aborts = 0;\t/* count of msgs ignored: aborts */\n\tthis.fs_nconnections_created = 0;\t/* count of conns created */\n\tthis.fs_nrequests_started = 0;\t\t/* count of reqs started */\n\tthis.fs_nrequests_completed = 0;\t/* count of reqs completed */\n\tthis.fs_nrequests_failed = 0;\t\t/* count of reqs failed */\n\n\tif (fastServerProvider === null) {\n\t\tfastServerProvider = fastServerProviderInit();\n\t}\n\n\tmod_assertplus.object(fastServerProvider);\n\tthis.fs_dtid = fastNservers++;\n\tthis.fs_dtp = fastServerProvider;\n}\n\n/* public methods */\n\nFastServer.prototype.registerRpcMethod = function (args)\n{\n\tvar rpcmethod, handler;\n\n\tmod_assertplus.object(args, 'args');\n\tmod_assertplus.string(args.rpcmethod, 'args.rpcmethod');\n\tmod_assertplus.func(args.rpchandler, 'args.rpchandler');\n\n\trpcmethod = args.rpcmethod;\n\thandler = args.rpchandler;\n\tmod_assertplus.ok(!this.fs_handlers.hasOwnProperty(rpcmethod),\n\t    'duplicate handler registered for method \"' + rpcmethod + '\"');\n\n\tthis.fs_log.info({ 'rpcmethod': rpcmethod }, 'registered RPC method');\n\tthis.fs_handlers[rpcmethod] = new FastRpcHandler({\n\t    'rpcmethod': rpcmethod,\n\t    'rpchandler': handler\n\t});\n};\n\nFastServer.prototype.close = function ()\n{\n\tvar error, connid;\n\n\tmod_assertplus.ok(arguments.length === 0,\n\t    'close() accepts no arguments');\n\n\tif (this.fs_closed) {\n\t\tthis.fs_log.warn('close() called while already shutting down');\n\t\treturn;\n\t}\n\n\tthis.fs_log.info('shutting down');\n\tthis.fs_closed = true;\n\terror = new VError('server is shutting down');\n\tfor (connid in this.fs_conns) {\n\t\tthis.connTerminate(this.fs_conns[connid], error);\n\t}\n};\n\n/*\n * Public methods for exposing debugging data over kang.\n *\n * Over kang, we expose basic statistics about the server (suitable for\n * real-time monitoring of basic activity), as well as objects of types:\n *\n *     fastconnection     describes a client that's currently connected,\n *\t\t\t  including local and remote address information\n *\t\t\t  and basic activity stats\n *\n *     fastrequest\t  describes a request that's currently outstanding,\n *\t\t\t  including which connection received it, how long it's\n *\t\t\t  been running, and what state it's in\n */\n\nFastServer.prototype.kangStats = function ()\n{\n\tvar rv = {};\n\trv['nConnectionsActive'] = Object.keys(this.fs_conns).length;\n\trv['nIgnoredMessagesNoConn'] = this.fs_nignored_noconn;\n\trv['nIgnoredMessagesBadConn'] = this.fs_nignored_badconn;\n\trv['nIgnoredMessagesAborts'] = this.fs_nignored_aborts;\n\trv['nConnectionsCreated'] = this.fs_nconnections_created;\n\trv['nRequestsStarted'] = this.fs_nrequests_started;\n\trv['nRequestsCompleted'] = this.fs_nrequests_completed;\n\trv['nRequestsFailed'] = this.fs_nrequests_failed;\n\treturn (rv);\n};\n\nFastServer.prototype.kangListTypes = function ()\n{\n\treturn ([ 'fastconnection', 'fastrequest' ]);\n};\n\nFastServer.prototype.kangListObjects = function (type)\n{\n\tif (type == 'fastconnection') {\n\t\treturn (Object.keys(this.fs_conns));\n\t}\n\n\tvar rv = [];\n\tmod_assertplus.equal(type, 'fastrequest');\n\tmod_jsprim.forEachKey(this.fs_conns, function (cid, conn) {\n\t\tObject.keys(conn.fc_pending).map(function (msgid) {\n\t\t\trv.push(cid + '/' + msgid);\n\t\t});\n\t});\n\n\treturn (rv);\n};\n\nFastServer.prototype.kangGetObject = function (type, id)\n{\n\tvar conn, rv;\n\tvar parts, req;\n\n\tif (type == 'fastconnection') {\n\t\tconn = this.fs_conns[id];\n\t\trv = {\n\t\t    'connid': conn.fc_connid,\n\t\t    'addrinfo': conn.fc_addrinfo,\n\t\t    'nStarted': conn.fc_nstarted,\n\t\t    'nCompleted': conn.fc_ncompleted,\n\t\t    'nFailed': conn.fc_nfailed,\n\t\t    'draining': conn.fc_draining,\n\t\t    'errorSocket': conn.fc_socket_error,\n\t\t    'errorServer': conn.fc_server_error,\n\t\t    'timeAccepted': conn.fc_taccepted.toISOString()\n\t\t};\n\t\treturn (rv);\n\t}\n\n\tmod_assertplus.equal(type, 'fastrequest');\n\tparts = id.split('/');\n\tmod_assertplus.equal(parts.length, 2);\n\tconn = this.fs_conns[parts[0]];\n\treq = conn.fc_pending[parts[1]];\n\trv = {\n\t    'connid': parts[0],\n\t    'msgid': parts[1],\n\t    'rpcmethod': req.fsr_rpcmethod,\n\t    'rpcargs': req.fsr_rpcargs,\n\t    'state': req.fsr_state,\n\t    'error': req.fsr_error,\n\t    'blackholed': req.fsr_blackhole !== null,\n\t    'timeStarted': req.fsr_tstarted.toISOString()\n\t};\n\treturn (rv);\n};\n\n/* private methods */\n\n/*\n * Connection lifecycle\n *\n * Connections are created when the underlying Server (usually either a TCP or\n * UDS server) emits a 'connection' event.  In connCreate(), we set up data\n * structures to manage a FastRpcConnection atop the new socket.\n *\n * Connections remain operational until they are abandoned for one of three\n * reasons:\n *\n *     o We read end-of-stream from the socket.  This is a graceful termination\n *       that we might expect when the remote side is shutting down after\n *       completing all of its RPC requests.\n *\n *     o We see an 'error' event on the socket.  This is an ungraceful\n *       termination of the connection that we might expect in the face of a\n *       network error.\n *\n *     o We proactively terminate the connection because we've read an invalid\n *       Fast protocol message or something else that's confused us as to the\n *       state of the connection, or we're shutting down the server.\n *\n * This is managed through the following call chain:\n *\n *                        connection arrives\n *                                |\n *                                v\n *            connCreate() sets up the FastRpcConnection\n *                                |\n *                                v\n *                       normal operation\n *                          |     |    |\n *        +-----------------+     |    +---------------------+\n *        |                       |                          |\n *        | onConnectionEnd():    | onConnectionError():     | connTerminate():\n *        | end-of-stream read    | socket error             | protocol error\n *        |                       |                          | or server\n *        |                       | connDisconnectRequests() | shutdown\n *        |                       |                          |\n *        +---------------------> + <------------------------+\n *                                |\n *                                v\n *                         connDrain():\n *                         wait for pending requests to complete\n *                                |\n *                                v\n *                         connection removed\n */\n\nFastServer.prototype.connCreate = function (sock)\n{\n\tvar self = this;\n\tvar cid, fastconn;\n\n\tcid = this.allocConnectionId(sock);\n\tmod_assertplus.ok(cid);\n\tmod_assertplus.ok(!this.fs_conns.hasOwnProperty(cid));\n\tfastconn = new FastRpcConnection({\n\t    'connId': cid,\n\t    'socket': sock,\n\t    'log': this.fs_log\n\t});\n\n\tthis.fs_nconnections_created++;\n\tthis.fs_conns[cid] = fastconn;\n\tthis.fs_dtp.fire('conn-create', function () {\n\t    return ([ self.fs_dtid, cid, fastconn.fc_addrinfo.label ]);\n\t});\n\tfastconn.fc_taccepted = new Date();\n\tfastconn.fc_ckddecoder.pipe(this.fs_msghandler, { 'end': false });\n\tfastconn.fc_log.info('connection received');\n\n\tsock.on('end', function onConnectionEnd() {\n\t\tself.onConnectionEnd(cid, fastconn);\n\t});\n\n\tsock.on('error', function onConnectionError(err) {\n\t\tself.onConnectionError(cid, fastconn, err);\n\t});\n\n\t/*\n\t * We shouldn't get here if the server is closing because the caller\n\t * should have shut down the server socket.  If we wind up seeing a\n\t * queued connection, terminate it immediately.\n\t */\n\tif (this.fs_closed) {\n\t\tthis.fs_log.warn('unexpected connection after server shutdown');\n\t\tthis.connTerminate(new VError('server is shutting down'));\n\t}\n};\n\n/*\n * Remove this connection because we've read end-of-stream.  We will wait for\n * pending requests to complete before actually removing the connection.\n */\nFastServer.prototype.onConnectionEnd = function (cid, conn)\n{\n\tmod_assertplus.ok(conn instanceof FastRpcConnection);\n\tmod_assertplus.ok(this.fs_conns.hasOwnProperty(cid));\n\tmod_assertplus.ok(this.fs_conns[cid] == conn);\n\n\t/*\n\t * Due to Node issue 6083, it's possible to see an \"end\" event after\n\t * having previously seen an \"error\" event.  Ignore such events.\n\t */\n\tif (conn.fc_socket_error !== null) {\n\t\tconn.fc_log.debug('ignoring end-of-stream after error');\n\t} else {\n\t\tconn.fc_ended = true;\n\t\tconn.fc_log.debug('end of input');\n\t\tthis.connDrain(conn);\n\t}\n};\n\n/*\n * Abandon this connection because we've seen a socket error.  This can happen\n * after the connection has already read end-of-stream or experienced a\n * protocol-level error.\n */\nFastServer.prototype.onConnectionError = function (cid, conn, err)\n{\n\tmod_assertplus.ok(conn instanceof FastRpcConnection);\n\tmod_assertplus.ok(err instanceof Error);\n\tmod_assertplus.ok(this.fs_conns.hasOwnProperty(cid));\n\tmod_assertplus.ok(this.fs_conns[cid] == conn);\n\tmod_assertplus.ok(conn.fc_socket_error === null);\n\tconn.fc_socket_error = err;\n\tconn.fc_log.warn(err, 'socket error');\n\n\t/*\n\t * If we've already seen a server error, then we're already tearing down\n\t * the connection.\n\t */\n\tif (conn.fc_server_error === null) {\n\t\tthis.connDisconnectRequests(conn);\n\t\tthis.connDrain(conn);\n\t}\n};\n\n/*\n * Allocate an internal connection id.  Callers will use this as a string (as an\n * object property name), and callers assume that it cannot be falsey.\n */\nFastServer.prototype.allocConnectionId = function ()\n{\n\treturn (this.fs_connallocator.alloc());\n};\n\n/*\n * Terminate this connection because of a protocol error or a server shutdown.\n * We do not allow existing requests to complete for this case.\n */\nFastServer.prototype.connTerminate = function (conn, err)\n{\n\tmod_assertplus.ok(conn instanceof FastRpcConnection);\n\tmod_assertplus.ok(err instanceof Error);\n\n\tif (conn.fc_server_error === null && conn.fc_socket_error === null) {\n\t\tconn.fc_log.warn(err, 'gracefully terminating connection');\n\t\tconn.fc_server_error = err;\n\t\tthis.connDisconnectRequests(conn);\n\t\tthis.connDrain(conn);\n\t} else {\n\t\tconn.fc_log.warn(err, 'already terminating connection');\n\t}\n};\n\n/*\n * Disconnect all requests associated with this connection from the connection\n * itself, generally as a result of a fatal error on the connection.\n */\nFastServer.prototype.connDisconnectRequests = function (conn)\n{\n\tvar msgid;\n\n\tfor (msgid in conn.fc_pending) {\n\t\tthis.requestDisconnect(conn.fc_pending[msgid]);\n\t}\n\n\tconn.fc_socket.destroy();\n};\n\n/*\n * Wait for outstanding requests to complete and then remove this connection\n * from the server.\n */\nFastServer.prototype.connDrain = function (conn)\n{\n\tvar self = this;\n\n\tmod_assertplus.ok(this.fs_conns[conn.fc_connid] == conn);\n\n\tif (!mod_jsprim.isEmpty(conn.fc_pending)) {\n\t\tmod_assertplus.ok(conn.fc_nstarted > conn.fc_ncompleted);\n\t\tconn.fc_log.debug({\n\t\t    'remaining': conn.fc_nstarted - conn.fc_ncompleted\n\t\t}, 'waiting for request drain');\n\t\tconn.fc_draining = true;\n\t} else {\n\t\tmod_assertplus.equal(conn.fc_nstarted, conn.fc_ncompleted);\n\t\tconn.fc_log.info('removing drained connection');\n\t\tdelete (this.fs_conns[conn.fc_connid]);\n\t\tthis.fs_dtp.fire('conn-destroy', function () {\n\t\t    return ([ self.fs_dtid, conn.fc_connid ]);\n\t\t});\n\n\t\t/*\n\t\t * As long as we didn't see a socket error and didn't already\n\t\t * terminate the socket, destroy the socket.  We could try to\n\t\t * end it gracefully, but we don't actually want to wait for the\n\t\t * client to shut it down cleanly.  If we already saw an error,\n\t\t * then there's nothing else to do.\n\t\t */\n\t\tif (conn.fc_socket_error === null &&\n\t\t    conn.fc_server_error === null) {\n\t\t\tconn.fc_socket.destroy();\n\t\t}\n\t}\n};\n\n\n/*\n * Message handling\n *\n * The only message we actually expect from clients is a DATA message, which\n * represents an RPC call.  This function handles those messages and either\n * ignores or issues appropriate errors for other kinds of messages.\n */\n\nFastServer.prototype.onMessage = function (message)\n{\n\tvar connid, conn;\n\tvar msgid, req;\n\tvar handler, handlerfunc;\n\tvar self = this;\n\n\tconnid = message.connId;\n\tmod_assertplus.ok(connid);\n\n\tif (!this.fs_conns.hasOwnProperty(connid)) {\n\t\t/*\n\t\t * This should only be possible if there were messages queued up\n\t\t * from a connection that has since been destroyed.\n\t\t */\n\t\tthis.fs_log.warn({\n\t\t    'fastMessage': message\n\t\t}, 'dropping message from unknown connection');\n\t\tthis.fs_nignored_noconn++;\n\t\treturn;\n\t}\n\n\tconn = this.fs_conns[connid];\n\tif (conn.fc_ended || conn.fc_socket_error !== null) {\n\t\tthis.fs_log.warn({\n\t\t    'fastMessage': message\n\t\t}, 'dropping message from abandoned connection');\n\t\tthis.fs_nignored_badconn++;\n\t\treturn;\n\t}\n\n\tif (message.status === mod_protocol.FP_STATUS_END) {\n\t\t/*\n\t\t * There's no reason clients should ever send us an \"end\" event.\n\t\t */\n\t\tthis.connTerminate(conn, new VError({\n\t\t    'name': 'FastProtocolError',\n\t\t    'info': {\n\t\t\t'fastReason': 'unexpected_status'\n\t\t    }\n\t\t}, 'unexpected END event from client'));\n\t\treturn;\n\t}\n\n\tmsgid = message.msgid;\n\tif (message.status === mod_protocol.FP_STATUS_ERROR) {\n\t\t/*\n\t\t * Intermediate versions of node-fast would send ERROR messages\n\t\t * to request RPC cancellation.  We don't support this.  See the\n\t\t * notes inside lib/fast_client.js for details on why.  Such\n\t\t * clients may expect a response from us in the form of an ERROR\n\t\t * message, but we just let the RPC complete normally.  After\n\t\t * all, because of the inherent race between receiving the abort\n\t\t * and completing the RPC, the client has to handle this\n\t\t * possibility anyway.\n\t\t */\n\t\tthis.fs_log.warn({\n\t\t    'msgid': msgid\n\t\t}, 'ignoring request to abort RPC (not supported)');\n\t\tthis.fs_nignored_aborts++;\n\t\treturn;\n\t}\n\n\tmod_assertplus.equal(message.status, mod_protocol.FP_STATUS_DATA);\n\tif (conn.fc_pending.hasOwnProperty(msgid)) {\n\t\tthis.connTerminate(conn, new VError({\n\t\t    'name': 'FastProtocolError',\n\t\t    'info': {\n\t\t\t'fastReason': 'duplicate_msgid',\n\t\t\t'rpcMsgid': msgid\n\t\t    }\n\t\t}, 'client attempted to re-use msgid'));\n\t\treturn;\n\t}\n\n\t/*\n\t * The message decoder only validates the Fast message and that the\n\t * payload in the message is a valid, non-null JSON object.  Here, we\n\t * validate the details of the payload.\n\t */\n\tconn.fc_nstarted++;\n\tthis.fs_nrequests_started++;\n\treq = new FastRpcServerRequest({\n\t    'server': this,\n\t    'fastMessage': message,\n\t    'fastConn': conn,\n\t    'log': conn.fc_log.child({ 'msgid': message.msgid }, true)\n\t});\n\tconn.fc_pending[req.fsr_msgid] = req;\n\treq.fsr_tstarted = new Date();\n\n\tmod_assertplus.equal(typeof (message.data), 'object');\n\tmod_assertplus.ok(message.data !== null);\n\tif (!message.data.m || !message.data.m.name ||\n\t    typeof (message.data.m.name) != 'string' ||\n\t    !message.data.d || !Array.isArray(message.data.d)) {\n\t\tthis.requestFail(req, new VError({\n\t\t    'name': 'FastError',\n\t\t    'info': {\n\t\t\t'fastReason': 'bad_data',\n\t\t\t'rpcMsgid': message.msgid,\n\t\t\t'rpcMessage': message\n\t\t    }\n\t\t}, 'RPC request is not well-formed'));\n\t\treturn;\n\t}\n\n\treq.fsr_rpcmethod = message.data.m.name;\n\treq.fsr_rpcargs = message.data.d;\n\tif (!this.fs_handlers.hasOwnProperty(req.fsr_rpcmethod)) {\n\t\tthis.requestFail(req, new VError({\n\t\t    'name': 'FastError',\n\t\t    'info': {\n\t\t\t'fastReason': 'bad_method',\n\t\t\t'rpcMethod': req.fsr_rpcmethod,\n\t\t\t'rpcMsgid': message.msgid\n\t\t    }\n\t\t}, 'unsupported RPC method: \"%s\"', req.fsr_rpcmethod));\n\t\treturn;\n\t}\n\n\n\thandler = this.fs_handlers[req.fsr_rpcmethod];\n\thandler.fh_nstarted++;\n\thandlerfunc = handler.fh_handler;\n\treq.fsr_handler = handler;\n\n\t/*\n\t * We skip the FR_S_QUEUED state because we do not currently limit\n\t * request concurrency.\n\t */\n\treq.fsr_state = FR_S_RUNNING;\n\treq.fsr_encoder.pipe(conn.fc_msgencoder, { 'end': false });\n\treq.fsr_docomplete = function () { self.requestComplete(req); };\n\treq.fsr_encoder.on('end', req.fsr_docomplete);\n\treq.fsr_log.debug('request started');\n\tthis.fs_dtp.fire('rpc-start', function () {\n\t\treturn ([ self.fs_dtid, conn.fc_connid, req.fsr_msgid,\n\t\t    req.fsr_rpcmethod ]);\n\t});\n\thandlerfunc(req.fsr_context);\n};\n\n/*\n * Request lifecycle\n *\n * Requests are created via server.onMessage() and then advance through the\n * following state machine:\n *\n *        +------------- FR_S_INIT -------------+\n *        |                                     |\n *        | validation okay                     |\n *        v                                     | validation failed\n *     FR_S_QUEUED                              | (invalid or missing method\n *        |                                     | name, missing arguments, etc.)\n *        | request handler invoked             |\n *        v                                     |\n *     FR_S_RUNNING                             |\n *        |                                     |\n *        | request handler ends stream or      |\n *        | invokes stream.fail(error)          |\n *        |                                     |\n *        +----------> FR_S_COMPLETE <----------+\n *\n * There are two paths for reaching FR_S_COMPLETE:\n *\n *     - normal termination (handler ends the stream): server.requestComplete()\n *\n *     - graceful error (handler invokes fail(error)): server.requestFail()\n *\n * In both cases, server.requestCleanup() is invoked to finish processing the\n * request.\n */\n\nvar FR_S_INIT     = 'INIT';\nvar FR_S_QUEUED   = 'QUEUED';\nvar FR_S_RUNNING  = 'RUNNING';\nvar FR_S_COMPLETE = 'COMPLETE';\n\n/*\n * Fail the given RPC request with the specified error.  This entry point is\n * invoked by RPC implementors returning an error.\n */\nFastServer.prototype.requestFail = function (request, error)\n{\n\tmod_assertplus.ok(request instanceof FastRpcServerRequest);\n\tmod_assertplus.ok(error instanceof Error,\n\t    'failure must be represented as an Error instance');\n\n\trequest.fsr_error = error;\n\trequest.fsr_state = FR_S_COMPLETE;\n\trequest.fsr_log.debug(error, 'request failed');\n\n\trequest.fsr_conn.fc_msgencoder.write(requestMakeMessage(\n\t    request, mod_protocol.FP_STATUS_ERROR, error));\n\tthis.requestCleanup(request);\n};\n\n/*\n * Mark the given RPC request having completed successfully.  This is implicitly\n * invoked by RPC implementors when they end their output stream.\n */\nFastServer.prototype.requestComplete = function (request)\n{\n\tmod_assertplus.equal(request.fsr_state, FR_S_RUNNING);\n\trequest.fsr_state = FR_S_COMPLETE;\n\trequest.fsr_log.debug('request completed normally');\n\tthis.requestCleanup(request);\n};\n\n/*\n * Disconnect this request from the underlying connection, usually because the\n * connection has failed.  We do not have a great way to signal cancellation to\n * the RPC method handler, so we allow the request to complete and ignore any\n * data sent.  This should not be a big deal, since Fast RPC requests are\n * intended to be very bounded in size anyway.\n */\nFastServer.prototype.requestDisconnect = function (request)\n{\n\tmod_assertplus.ok(request instanceof FastRpcServerRequest);\n\n\tif (request.fsr_state != FR_S_RUNNING) {\n\t\tmod_assertplus.equal(request.fsr_state, FR_S_COMPLETE);\n\t\treturn;\n\t}\n\n\tmod_assertplus.ok(request.fsr_error === null);\n\tmod_assertplus.ok(request.fsr_blackhole === null);\n\trequest.fsr_log.info('disconnecting request');\n\trequest.fsr_context.unpipe(request.fsr_encoder);\n\trequest.fsr_encoder.unpipe(request.fsr_conn.fc_msgencoder);\n\trequest.fsr_encoder.removeListener('end', request.fsr_docomplete);\n\n\trequest.fsr_blackhole = new NullSink();\n\trequest.fsr_context.pipe(request.fsr_blackhole);\n\trequest.fsr_blackhole.on('finish', request.fsr_docomplete);\n};\n\n/*\n * Common function for completing execution of the given RPC request.\n */\nFastServer.prototype.requestCleanup = function (request)\n{\n\tvar conn;\n\tvar self = this;\n\n\tmod_assertplus.equal(request.fsr_state, FR_S_COMPLETE);\n\tconn = request.fsr_conn;\n\n\tmod_assertplus.ok(conn.fc_pending.hasOwnProperty(request.fsr_msgid));\n\tmod_assertplus.ok(conn.fc_pending[request.fsr_msgid] == request);\n\tdelete (conn.fc_pending[request.fsr_msgid]);\n\n\tconn.fc_ncompleted++;\n\tthis.fs_nrequests_completed++;\n\n\tif (request.fsr_handler !== null) {\n\t\trequest.fsr_handler.fh_ncompleted++;\n\n\t\t/*\n\t\t * If we never assigned a handler, then we didn't fire the\n\t\t * rpc-start probe.\n\t\t */\n\t\tthis.fs_dtp.fire('rpc-done', function () {\n\t\t\treturn ([ self.fs_dtid,\n\t\t\t    conn.fc_connid, request.fsr_msgid ]);\n\t\t});\n\t}\n\n\tif (request.fsr_error !== null) {\n\t\tconn.fc_nfailed++;\n\t\tthis.fs_nrequests_failed++;\n\t\tif (request.fsr_handler !== null) {\n\t\t\trequest.fsr_handler.fh_nerrors++;\n\t\t}\n\t}\n\n\tif (conn.fc_draining) {\n\t\tthis.connDrain(conn);\n\t}\n};\n\n\n/*\n * Helper classes\n *\n * The classes below generally contain no methods of their own except as needed\n * to implement various object-mode streams.\n */\n\n/*\n * Each FastRpcHandler instance represents a registered RPC method.  Besides the\n * user's handler, we keep track of basic stats about this handler's usage.\n * Named arguments include:\n *\n *     rpcmethod\tstring name of the RPC method\n *\n *     rpchandler\tJavaScript function invoked for each outstanding\n *     \t\t\trequest.\n *\n * When RPC requests are received for this method, the function is invoked as:\n *\n *     handler(context);\n *\n * where \"context\" is an object-mode writable stream to which the RPC method\n * implementor should write plain JavaScript objects that will be received on\n * the client.  The RPC is considered successfully completed when the stream is\n * ended.  If the RPC fails, the caller should _not_ end the stream, but instead\n * invoke context.fail(err) with an error that will be sent to the client.\n * After the RPC completes (either by ending the stream or by invoking fail()),\n * only read-only operations on \"context\" are allowed.\n */\nfunction FastRpcHandler(args)\n{\n\tmod_assertplus.object(args, 'args');\n\tmod_assertplus.string(args.rpcmethod, 'args.rpcmethod');\n\tmod_assertplus.func(args.rpchandler, 'args.rpchandler');\n\n\tthis.fh_rpcmethod = args.rpcmethod;\n\tthis.fh_handler = args.rpchandler;\n\tthis.fh_nstarted = 0;\t\t/* count of started RPC calls */\n\tthis.fh_ncompleted = 0;\t\t/* count of completed RPC calls */\n\tthis.fh_nerrors = 0;\t\t/* count of completed, failed calls */\n}\n\n\n/*\n * Each FastRpcConnection instance represents a connection to an RPC client.\n * See \"Connection lifecycle\" for details about how this object is used.\n * Named arguments:\n *\n *     connId\tunique identifier for this connection\n *\n *     socket\tunderlying socket for communicating with client\n *\n *     log      bunyan-style logger\n */\nfunction FastRpcConnection(args)\n{\n\tmod_assertplus.object(args, 'args');\n\tmod_assertplus.ok(args.connId, 'args.connId');\n\tmod_assertplus.object(args.socket, 'args.socket');\n\tmod_assertplus.object(args.log, 'args.log');\n\n\tthis.fc_connid = args.connId;\t/* see above */\n\tthis.fc_socket = args.socket;\t/* see above */\n\tthis.fc_addrinfo = mod_subr.summarizeSocketAddrs(this.fc_socket);\n\tthis.fc_log = args.log.child({\n\t    'connId': this.fc_connid,\n\t    'client': this.fc_addrinfo.label\n\t});\n\tthis.fc_pending = {};\t\t/* pending requests */\n\tthis.fc_nstarted = 0;\t\t/* count of requests started */\n\tthis.fc_ncompleted = 0;\t\t/* count of requests completed */\n\tthis.fc_nfailed = 0;\t\t/* count of requests failed */\n\tthis.fc_taccepted = null;\t/* time when the conn was accepted */\n\tthis.fc_ended = false;\t\t/* end-of-stream has been read */\n\tthis.fc_socket_error = null;\t/* conn experienced socket error */\n\tthis.fc_server_error = null;\t/* proto error or shutdown */\n\tthis.fc_draining = false;\t/* waiting for connection to drain */\n\n\t/*\n\t * Messages written to fc_msgencoder are encoded and sent to the socket.\n\t */\n\tthis.fc_msgencoder = new mod_protocol.FastMessageEncoder();\n\tthis.fc_msgencoder.pipe(this.fc_socket);\n\n\t/*\n\t * We'll end up piping each request's encoder to this connection-wide\n\t * encoder.  As a result, it may have listeners proportional to the\n\t * number of outstanding requests.  Disable Node's ill-considered\n\t * warning about the maximum number of listeners.\n\t */\n\tthis.fc_msgencoder.setMaxListeners(0);\n\n\t/*\n\t * Messages read from the socket are annotated with this connection id\n\t * (using the FastRpcConnectionDecoder transform stream) and then\n\t * emitted from fc_ckddecoder.\n\t */\n\tthis.fc_rawdecoder = new mod_protocol.FastMessageDecoder();\n\tthis.fc_socket.pipe(this.fc_rawdecoder);\n\tthis.fc_ckddecoder = new FastRpcConnectionDecoder({ 'fastConn': this });\n\tthis.fc_rawdecoder.pipe(this.fc_ckddecoder);\n}\n\n\n/*\n * This object-mode Transform stream annotates Fast protocol messages with the\n * connection on which they were received.\n */\nfunction FastRpcConnectionDecoder(args)\n{\n\tmod_assertplus.object(args, 'args');\n\tmod_assertplus.object(args.fastConn, 'args.fastConn');\n\n\tthis.fcd_conn = args.fastConn;\n\tmod_stream.Transform.call(this, {\n\t    'objectMode': true,\n\t    'highWaterMark': 1\n\t});\n}\n\nmod_util.inherits(FastRpcConnectionDecoder, mod_stream.Transform);\n\nFastRpcConnectionDecoder.prototype._transform = function (msg, _, callback)\n{\n\tmod_assertplus.object(msg);\n\tmod_assertplus.number(msg.msgid);\n\tmod_assertplus.ok(!msg.hasOwnProperty('connId'));\n\tmsg.connId = this.fcd_conn.fc_connid;\n\tthis.push(msg);\n\tsetImmediate(callback);\n};\n\n\n/*\n * The FastMessageHandler is just a transform stream that takes incoming Fast\n * protocol messages and dispatches them to the FastServer for which this\n * handler was created.  Today, this class does not do any real flow control or\n * concurrency management.  However, by phrasing this as an object-mode Writable\n * stream, this is where we could implement flow control without having to\n * modify much else.\n */\nfunction FastMessageHandler(args)\n{\n\tmod_assertplus.object(args, 'args');\n\tmod_assertplus.object(args.server, 'args.server');\n\n\tthis.fmh_server = args.server;\n\n\tmod_stream.Writable.call(this, {\n\t    'objectMode': true,\n\t    'highWaterMark': 0\n\t});\n}\n\nmod_util.inherits(FastMessageHandler, mod_stream.Writable);\n\nFastMessageHandler.prototype._write = function (obj, _, callback)\n{\n\tthis.fmh_server.onMessage(obj);\n\tsetImmediate(callback);\n};\n\n\n/*\n * A FastRpcServerRequest represents an RPC request received on the server from\n * a client.  See \"Request lifecycle\" above for details.  Named arguments:\n *\n *     fastMessage (object) incoming Fast protocol message that began this RPC\n *\n *     fastConn    (object) connection on which this request was received\n *\n *     server      (object) handle to the containing Fast server\n *\n *     log         (object) bunyan-style logger\n */\nfunction FastRpcServerRequest(args)\n{\n\tvar request = this;\n\n\tmod_assertplus.object(args, 'args');\n\tmod_assertplus.object(args.fastMessage, 'args.fastMessage');\n\tmod_assertplus.object(args.server, 'args.server');\n\tmod_assertplus.object(args.log, 'args.log');\n\tmod_assertplus.object(args.fastConn, 'args.fastConn');\n\n\t/*\n\t * This should already have been validated by the Fast parser.  However,\n\t * the contents of the message's \"data\" field have not yet been\n\t * validated.\n\t */\n\tmod_assertplus.number(args.fastMessage.msgid, 'args.fastMessage.msgid');\n\n\tthis.fsr_message = args.fastMessage;\n\tthis.fsr_msgid = args.fastMessage.msgid;\n\tthis.fsr_server = args.server;\n\tthis.fsr_conn = args.fastConn;\n\tthis.fsr_log = args.log;\n\n\tthis.fsr_rpcmethod = null;\t/* filled in after validation */\n\tthis.fsr_rpcargs = null;\t/* filled in after validation */\n\tthis.fsr_handler = null;\t/* filled in after validation */\n\tthis.fsr_tstarted = null;\t/* time the request started */\n\tthis.fsr_state = FR_S_INIT;\t/* see state machine above */\n\tthis.fsr_encoder = new FastRpcResponseEncoder({ 'request': this });\n\tthis.fsr_docomplete = null;\t/* callback for completion */\n\tthis.fsr_error = null;\t\t/* error, if any */\n\tthis.fsr_blackhole = null;\t/* see requestDisconnect() */\n\n\t/*\n\t * The \"context\" is a handle by which implementors of RPC methods can\n\t * inspect the request and send response data.  Per well-established\n\t * design patterns, we provide a functional interface to this\n\t * information so that we can add additional information in the future\n\t * by just adding new methods to the context object.\n\t *\n\t * We could just use this object, rather than constructing a new object\n\t * specifically for this purpose.  Indeed, this author is not generally\n\t * a proponent of the following pattern for data hiding, as it disrupts\n\t * debuggability.  Sadly, past experience has shown that some\n\t * implementations cannot resist the temptation to peek and poke at\n\t * private fields.  Given how crisp this interface boundary is, we deem\n\t * it worthwhile to eliminate the possibility of malfeasance.\n\t */\n\tthis.fsr_context = new mod_stream.PassThrough({\n\t    'objectMode': true,\n\t    'highWaterMark': 1\n\t});\n\tthis.fsr_context.connectionId = function ctxConnectionId() {\n\t\treturn (request.fsr_conn.fc_connid);\n\t};\n\tthis.fsr_context.requestId = function ctxRequestId() {\n\t\treturn (request.fsr_msgid);\n\t};\n\tthis.fsr_context.methodName = function ctxMethodName() {\n\t\treturn (request.fsr_rpcmethod);\n\t};\n\tthis.fsr_context.argv = function ctxArgv() {\n\t\t/*\n\t\t * For clarity and debuggability, callers ought to avoid mucking\n\t\t * with the arguments that they're given.  Normally, we'd copy\n\t\t * them here to eliminate this as a possibility.  But the cost\n\t\t * of a deep copy is a relatively high percentage of the on-CPU\n\t\t * time for many RPC calls.  Plus, it's unlikely that\n\t\t * modifications to these arguments would affect code other than\n\t\t * the caller.\n\t\t */\n\t\treturn (request.fsr_rpcargs.slice());\n\t};\n\tthis.fsr_context.fail = function ctxFail(err) {\n\t\treturn (request.fsr_server.requestFail(request, err));\n\t};\n\n\tthis.fsr_context.pipe(this.fsr_encoder);\n}\n\n\nfunction FastRpcResponseEncoder(args)\n{\n\tmod_assertplus.object(args, 'args');\n\tmod_assertplus.object(args.request, 'args.request');\n\n\tmod_stream.Transform.call(this, {\n\t    'objectMode': true,\n\t    'highWaterMark': 1\n\t});\n\tthis.fse_request = args.request;\n\tthis.fse_ndropped = 0;\n}\n\nmod_util.inherits(FastRpcResponseEncoder, mod_stream.Transform);\n\nFastRpcResponseEncoder.prototype._transform = function (obj, _, callback)\n{\n\tif (this.fse_request.fsr_state != FR_S_RUNNING) {\n\t\t/*\n\t\t * The RPC handler should not be writing data after calling\n\t\t * fail() (and completing the request).  However, there's some\n\t\t * asynchrony between when they write data and when it reaches\n\t\t * our transform, so this isn't necessarily invalid.\n\t\t */\n\t\tthis.fse_ndropped++;\n\t\tsetImmediate(callback);\n\t\treturn;\n\t}\n\n\tmod_assertplus.ok(typeof (obj) == 'object' && obj !== null,\n\t    'can only send non-null objects');\n\tthis.push(requestMakeMessage(this.fse_request,\n\t    mod_protocol.FP_STATUS_DATA, [ obj ]));\n\tsetImmediate(callback);\n};\n\nFastRpcResponseEncoder.prototype._flush = function (callback)\n{\n\tif (this.fse_request.fsr_state == FR_S_RUNNING) {\n\t\tthis.push(requestMakeMessage(this.fse_request,\n\t\t    mod_protocol.FP_STATUS_END, null));\n\t}\n\n\tsetImmediate(callback);\n};\n\n/*\n * Construct a Fast RPC message that's part of a response for the given request.\n */\nfunction requestMakeMessage(request, status, data)\n{\n\tvar datum;\n\n\tmod_assertplus.ok(request instanceof FastRpcServerRequest);\n\tif (status == mod_protocol.FP_STATUS_ERROR) {\n\t\tmod_assertplus.ok(data instanceof Error);\n\n\t\t/*\n\t\t * The marshaling of Errors is a little sketchy, owing partly to\n\t\t * the history of Fast and partly to the sketchy definition of\n\t\t * Errors in JavaScript.  The goal is to allow the client\n\t\t * program to reconstitute an Error object that looks like the\n\t\t * one we have here.\n\t\t *\n\t\t * We need to provide at least \"name\" and \"message\" to make it\n\t\t * look like a JavaScript Error.  As a departure from the\n\t\t * previous implementation, we do not provide the \"stack\" field.\n\t\t * It's way too confusing for the client to wind up with an\n\t\t * Error whose stacktrace is from a different program on a\n\t\t * different system.  (The filenames and line numbers in the\n\t\t * stack trace may not even exist on the client system, and\n\t\t * they certainly may not refer to the same files and line\n\t\t * numbers even if they do exist.)\n\t\t *\n\t\t * We provide \"info\" as VError.info() because this is the modern\n\t\t * way to provide information properties on Errors.\n\t\t *\n\t\t * We provide \"context\" and \"ase_errors\" because the old Fast\n\t\t * implementation did so.  \"context\" is how old Fast servers\n\t\t * would specify error metadata (before VError.info() existed).\n\t\t * \"ase_errors\" is a private implementation property of\n\t\t * MultiError, and we never should have exposed it, but things\n\t\t * potentially do depend on it.\n\t\t */\n\t\tdatum = {\n\t\t    'name': data.name,\n\t\t    'message': data.message,\n\t\t    'context': data.context || {},\n\t\t    'info': VError.info(data),\n\t\t    'ase_errors': data.ase_errors\n\t\t};\n\t} else if (status == mod_protocol.FP_STATUS_END) {\n\t\tmod_assertplus.ok(data === null);\n\t\tdatum = [];\n\t} else {\n\t\tmod_assertplus.equal(status, mod_protocol.FP_STATUS_DATA);\n\t\tmod_assertplus.ok(Array.isArray(data));\n\t\tdatum = data;\n\t}\n\n\treturn ({\n\t    'msgid': request.fsr_msgid,\n\t    'status': status,\n\t    'data': {\n\t\t'm': {\n\t\t    'uts': mod_microtime.now(),\n\t\t    'name': request.fsr_rpcmethod\n\t\t},\n\t\t'd': datum\n\t    }\n\t});\n}\n\n\n/*\n * Object-mode data sink that drops all data.\n */\nfunction NullSink()\n{\n\tthis.ns_nwritten = 0;\n\tmod_stream.Writable.call(this, {\n\t    'objectMode': true,\n\t    'highWaterMark': 1\n\t});\n}\n\nmod_util.inherits(NullSink, mod_stream.Writable);\n\nNullSink.prototype._write = function (_1, _2, callback)\n{\n\tthis.ns_nwritten++;\n\tsetImmediate(callback);\n};\n\n\n/*\n * Initialize the DTrace provider for the Fast server.\n */\nfunction fastServerProviderInit()\n{\n\tvar dtp;\n\n\tdtp = mod_dtrace.createDTraceProvider('fastserver');\n\n\t/*\n\t * conn-create: connection was created\n\t *\n\t *     arg0    int     unique identifier for this server in this process\n\t *     arg1    int     unique identifier for this client in this server\n\t *     arg2    string  human-readable label for this client (usually\n\t *                     a summary of the TCP connection)\n\t */\n\tdtp.addProbe('conn-create', 'int', 'int', 'char *');\n\n\t/*\n\t * conn-destroy: connection was destroyed\n\t *\n\t *     arg0    int     see conn-create arg0.\n\t *     arg1    int     see conn-create arg1.\n\t */\n\tdtp.addProbe('conn-destroy', 'int', 'int');\n\n\t/*\n\t * rpc-start: server starts handling RPC request\n\t *\n\t *     arg0    int     see conn-create arg0.\n\t *     arg1    int     see conn-create arg1.\n\t *     arg2    int     unique identifier for this request in this client\n\t *     arg3    string  RPC method name\n\t */\n\tdtp.addProbe('rpc-start', 'int', 'int', 'int', 'char *');\n\n\t/*\n\t * rpc-done: server finishes handling RPC request\n\t *\n\t *     arg0    int     see conn-create arg0.\n\t *     arg1    int     see conn-create arg1.\n\t *     arg2    int     unique identifier for this request in this\n\t *\t\t       process\n\t */\n\tdtp.addProbe('rpc-done', 'int', 'int', 'int');\n\tdtp.enable();\n\treturn (dtp);\n}\n","/home/travis/build/npmtest/node-npmtest-fast/node_modules/fast/lib/subr.js":"/*\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\n/*\n * Copyright (c) 2016, Joyent, Inc.\n */\n\n/*\n * lib/fast_subr.js: useful utility functions that have not yet been abstracted\n * into separate Node modules.\n */\n\nvar mod_assertplus = require('assert-plus');\n\nexports.summarizeSocketAddrs = summarizeSocketAddrs;\nexports.IdAllocator = IdAllocator;\n\n/*\n * Given a Node socket, return an object summarizing it for debugging purposes.\n * It's sad how complicated this is.  This is only tested for Node v0.10 and\n * v0.12.\n */\nfunction summarizeSocketAddrs(sock)\n{\n\tvar laddr, rv;\n\n\tladdr = sock.address();\n\n\tif (sock.remoteAddress === undefined &&\n\t    sock.remotePort === undefined &&\n\t    sock.remoteFamily === undefined) {\n\t\treturn ({ 'socketType': 'UDS (inferred)', 'label': 'UDS' });\n\t}\n\n\trv = {};\n\trv['remoteAddress'] = sock.remoteAddress;\n\trv['remotePort'] = sock.remotePort;\n\n\tif (laddr === null) {\n\t\trv['socketType'] = 'unknown';\n\t\trv['label'] = 'unknown';\n\t} else {\n\t\trv['socketType'] = laddr.family ? laddr.family : 'unknown';\n\t\trv['localAddress'] = laddr.address;\n\t\trv['localPort'] = laddr.port;\n\n\t\tif (sock.remoteAddress) {\n\t\t\trv['label'] = sock.remoteAddress;\n\t\t\tif (sock.remotePort) {\n\t\t\t\trv['label'] += ':' + sock.remotePort;\n\t\t\t}\n\t\t} else {\n\t\t\trv['label'] = 'unknown';\n\t\t}\n\t}\n\n\treturn (rv);\n}\n\n/*\n * IdAllocator is a cheesy interface for allocating non-negative integer\n * identifiers.  This is similar to the way an OS pid allocator might work,\n * where ids are allocated in increasing order to avoid immediate reuse, but ids\n * eventually will wrap around.  It's expected that callers will use these ids\n * as strings (e.g., as object property names).\n *\n * This is a very simple implementation that we expect to be sufficient for our\n * purposes.  However, it's not very efficient.  We may want to look at\n * something like the Bonwick vmem allocator in the future.\n *\n * This interface considers it a programmer error to attempt to allocate more\n * ids than are currently outstanding (i.e., to attempt to allocate when no\n * resources are available).  That will result in a thrown exception that should\n * not be caught.  If we want to make this survivable in the future, we could\n * improve this, but it's extraordinarily unlikely in the use-cases for which\n * this is intended so it's not worth special-casing at this point.\n *\n * Arguments:\n *\n *     min (number)    minimum allowed id (absolute minimum: 0)\n *\n *     max (number)    maximum allowed id (absolute maximum: 2^31)\n *\n *     isAllocated     function that takes an id and returns whether or not\n *     (function)      the id is still allocated.  This is a obviously  cheesy,\n *\t\t       but given that callers are keeping track of it, we may as\n *\t\t       well just ask them rather than keep a shadow copy of the\n *\t\t       allocated ids.\n *\n */\nfunction IdAllocator(args)\n{\n\tmod_assertplus.object(args, 'args');\n\tmod_assertplus.number(args.min, 'args.min');\n\tmod_assertplus.number(args.max, 'args.max');\n\tmod_assertplus.func(args.isAllocated, 'args.isAllocated');\n\tmod_assertplus.ok(args.min < args.max, 'min must be less than max');\n\tmod_assertplus.ok(args.min >= 0, 'min must be non-negative');\n\tmod_assertplus.ok(args.max <= Math.pow(2, 31), 'max is too big');\n\n\tthis.ida_min = args.min;\n\tthis.ida_max = args.max;\n\tthis.ida_isalloc = args.isAllocated;\n\tthis.ida_nextid = this.ida_min;\n}\n\nIdAllocator.prototype.alloc = function ()\n{\n\tvar start, next;\n\n\tstart = this.ida_nextid;\n\tnext = start;\n\twhile (this.ida_isalloc(next)) {\n\t\tnext++;\n\n\t\tif (next > this.ida_max) {\n\t\t\tnext = this.ida_min;\n\t\t}\n\n\t\tif (next == start) {\n\t\t\tthrow (new Error('all ids allocated'));\n\t\t}\n\t}\n\n\tthis.ida_nextid = next + 1;\n\tif (this.ida_nextid > this.ida_max) {\n\t\tthis.ida_nextid = this.ida_min;\n\t}\n\n\treturn (next);\n};\n"}